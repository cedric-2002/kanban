// src/index.ts
import fs4 from "fs";
import path6 from "path";
import crypto from "crypto";
import anyMatch from "anymatch";
import { pathToFileURL } from "url";

// src/server-entry-template.ts
import path from "path";

// src/render-assets-runtime.ts
var renderAssetsRuntimeId = "\0marko-render-assets.mjs";
function getRenderAssetsRuntime(opts) {
  return `${opts.basePathVar && opts.isBuild ? `const base = globalThis.${opts.basePathVar};
if (typeof base !== "string") throw new Error("${opts.basePathVar} must be defined when using basePathVar.");
if (!base.endsWith("/")) throw new Error("${opts.basePathVar} must end with a '/' when using basePathVar.");` : "const base = import.meta.env.BASE_URL;"}
export function addAssets(g, newEntries) {
  const entries = g.___viteEntries;
  if (entries) {
    g.___viteEntries = entries.concat(newEntries);
    return true;
  }
  g.___viteEntries = newEntries;
  g.___viteRenderAssets = renderAssets;
  g.___viteInjectAttrs = g.cspNonce
    ? \` nonce="\${g.cspNonce.replace(/"/g, "&#39;")}"\`
    : "";
  g.___viteSeenIds = new Set();
  ${opts.runtimeId ? `g.runtimeId = ${JSON.stringify(opts.runtimeId)};` : ""}
}

function renderAssets(slot) {
  const entries = this.___viteEntries;
  let html = "";

  if (entries) {
    const seenIds = this.___viteSeenIds;
    const slotWrittenEntriesKey = \`___viteWrittenEntries-\${slot}\`;
    const lastWrittenEntry = this[slotWrittenEntriesKey] || 0;
    const writtenEntries = (this[slotWrittenEntriesKey] = entries.length);

    if(!this.___flushedMBP && slot !== "head-prepend") {
        this.___flushedMBP = true;

        html += \`<script\${this.___viteInjectAttrs}>${opts.runtimeId ? `$mbp_${opts.runtimeId}` : "$mbp"}=\${JSON.stringify(base)}</script>\`
    }

    for (let i = lastWrittenEntry; i < writtenEntries; i++) {
      let entry = entries[i];

      if (typeof entry === "string") {
        entry = __MARKO_MANIFEST__[entry] || {};
      }${opts.isBuild ? "" : ` else if (slot === "head") {
        // In dev mode we have is a list entries of the top level modules that need to be imported.
        // To avoid FOUC we will hide the page until all of these modules are loaded.
        const { preload } = entry;
        if (preload) {
          html += \`<script class=marko-vite-preload async blocking=render type=module\${this.___viteInjectAttrs}>\`;
          for (const id of preload) {
            html += \`import \${JSON.stringify(base + id)};\`;
          }

          html += "document.querySelectorAll('.marko-vite-preload').forEach((el) => el.remove());";
          html += "document.documentElement.style.visibility='';";
          html +=
            "if(document.documentElement.getAttribute('style')==='')document.documentElement.removeAttribute('style');";
          html += \`</script><script class=marko-vite-preload\${this.___viteInjectAttrs}>document.documentElement.style.visibility='hidden'</script>\`;
        }
      }`}

      const parts = entry[slot];

      if (parts) {
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          switch (part) {
            case 0: /** InjectType.AssetAttrs */
              html += this.___viteInjectAttrs;
              break;
            case 1: /** InjectType.PublicPath */
              html += base;
              break;
            case 2: /** InjectType.Dedupe */ {
              const id = parts[++i];
              const skipParts = parts[++i];
              if (seenIds.has(id)) {
                i += skipParts;
              } else {
                seenIds.add(id);
              }
              break;
            }
            default:
              html += part;
              break;
          }
        }
      }
    }
  }

  return html;
}
`;
}

// src/server-entry-template.ts
var server_entry_template_default = async (opts) => {
  const fileNameStr = JSON.stringify(`./${path.basename(opts.fileName)}`);
  return `import template from ${fileNameStr};
export * from ${fileNameStr};
import { addAssets } from "${renderAssetsRuntimeId}";

$ const g = out.global;
$ const writeSync = addAssets(g, [${opts.entryData.join(",")}]);

<if(writeSync)>
  $!{
    g.___viteRenderAssets("head-prepend") +
    g.___viteRenderAssets("head") +
    g.___viteRenderAssets("body-prepend")
  }
</>
<else>
  <__flush_here_and_after__>
    $!{
      g.___viteRenderAssets("head-prepend") +
      g.___viteRenderAssets("head") +
      g.___viteRenderAssets("body-prepend")
    }
  </__flush_here_and_after__>
</>

<\${template} ...input/>
<init-components/>
<await-reorderer/>

<if(writeSync)>
  $!{g.___viteRenderAssets("body")}
</>
<else>
  <__flush_here_and_after__>
    $!{g.___viteRenderAssets("body")}
  </__flush_here_and_after__>
</>
`;
};

// src/manifest-generator.ts
import { Parser } from "htmlparser2";
import { ElementType as ElementType2 } from "domelementtype";
import { DomHandler } from "domhandler";

// src/serializer.ts
import { ElementType } from "domelementtype";
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function serialize(basePath, nodes, preload, parts) {
  let curString = parts ? parts.pop() : "";
  parts ??= [];
  for (const node of nodes) {
    switch (node.type) {
      case ElementType.Tag:
      case ElementType.Style:
      case ElementType.Script: {
        const tag = node;
        const { name } = tag;
        let urlAttr;
        let isDedupe = 0;
        switch (tag.tagName) {
          case "script":
            if (tag.attribs.src) {
              if (curString) {
                parts.push(curString);
                curString = "";
              }
              isDedupe = parts.push(2 /* Dedupe */, tag.attribs.src, 0) - 1;
            }
            parts.push(`${curString}<${name}`, 0 /* AssetAttrs */);
            curString = "";
            urlAttr = "src";
            break;
          case "style":
            parts.push(`${curString}<${name}`, 0 /* AssetAttrs */);
            curString = "";
            break;
          case "link":
            if (tag.attribs.href) {
              if (curString) {
                parts.push(curString);
                curString = "";
              }
              isDedupe = parts.push(
                2 /* Dedupe */,
                [tag.attribs.rel || "", tag.attribs.href, tag.attribs.as].filter((it) => it != null).join("#"),
                0
              ) - 1;
            }
            urlAttr = "href";
            if (tag.attribs.rel === "stylesheet" || tag.attribs.rel === "modulepreload" || tag.attribs.as === "style" || tag.attribs.as === "script") {
              parts.push(`${curString}<${name}`, 0 /* AssetAttrs */);
              curString = "";
            } else {
              curString += `<${name}`;
            }
            break;
          default:
            curString += `<${name}`;
            break;
        }
        for (const attr of tag.attributes) {
          if (attr.value === "") {
            curString += ` ${attr.name}`;
          } else if (attr.name === urlAttr) {
            const id = stripBasePath(basePath, attr.value).replace(/^\.\//, "");
            if (tag.name === "script") {
              preload.push(id);
            }
            curString += ` ${attr.name}="`;
            parts.push(
              curString,
              1 /* PublicPath */,
              id.replace(/"/g, "&#39;") + '"'
            );
            curString = "";
          } else {
            curString += ` ${attr.name}="${attr.value.replace(/"/g, "&#39;")}"`;
          }
        }
        curString += ">";
        if (tag.children.length) {
          parts.push(curString);
          serialize(basePath, tag.children, preload, parts);
          curString = parts.pop();
        }
        if (!voidElements.has(name)) {
          curString += `</${name}>`;
        }
        if (isDedupe) {
          if (curString) {
            parts.push(curString);
            curString = "";
          }
          parts[isDedupe] = parts.length - isDedupe - 1;
        }
        break;
      }
      case ElementType.Text: {
        const text = node.data;
        if (!/^\s*$/.test(text)) {
          curString += text;
        }
        break;
      }
      case ElementType.Comment:
        curString += `<!--${node.data}-->`;
        break;
    }
  }
  if (curString) {
    parts.push(curString);
  }
  return parts;
}
function stripBasePath(basePath, path7) {
  if (path7.startsWith(basePath)) return path7.slice(basePath.length);
  return path7;
}

// src/manifest-generator.ts
var MARKER_COMMENT = "MARKO_VITE";
function generateDocManifest(basePath, rawHtml) {
  return new Promise((resolve2, reject) => {
    const parser = new Parser(
      new DomHandler(function(err, dom) {
        if (err) {
          return reject(err);
        }
        const htmlChildren = dom.find(isElement).childNodes;
        const preload = [];
        const headPrepend = [];
        const head = [];
        const bodyPrepend = [];
        const body = [];
        splitNodesByMarker(
          htmlChildren.find(
            (node) => isElement(node) && node.tagName === "head"
          ).childNodes,
          headPrepend,
          head
        );
        splitNodesByMarker(
          htmlChildren.find(
            (node) => isElement(node) && node.tagName === "body"
          ).childNodes,
          bodyPrepend,
          body
        );
        resolve2({
          preload,
          "head-prepend": serializeOrNull(basePath, headPrepend, preload),
          head: serializeOrNull(basePath, head, preload),
          "body-prepend": serializeOrNull(basePath, bodyPrepend, preload),
          body: serializeOrNull(basePath, body, preload)
        });
      })
    );
    parser.write(rawHtml);
    parser.end();
  });
}
function generateInputDoc(entry) {
  return `<!DOCTYPE html><html><head><!--${MARKER_COMMENT}--></head><body><!--${MARKER_COMMENT}--><script async type="module" src=${JSON.stringify(
    entry
  )}></script></body></html>`;
}
function serializeOrNull(basePath, nodes, preload) {
  const result = serialize(basePath, nodes, preload);
  if (result.length) {
    return result;
  }
  return null;
}
function splitNodesByMarker(nodes, before, after) {
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.data === MARKER_COMMENT) {
      i++;
      for (; i < nodes.length; i++) {
        node = nodes[i];
        after.push(node);
      }
      break;
    }
    before.push(node);
  }
}
function isElement(node) {
  return node.type === ElementType2.Tag;
}

// src/esbuild-plugin.ts
import fs from "fs";
import path2 from "path";
var markoErrorRegExp = /^(.+?)(?:\((\d+)(?:\s*,\s*(\d+))?\))?: (.*)$/gm;
function esbuildPlugin(compiler, config) {
  return {
    name: "marko",
    async setup(build) {
      const { platform = "browser" } = build.initialOptions;
      const isScan = build.initialOptions.plugins?.some(
        (v) => v.name === "vite:dep-scan"
      );
      const virtualFiles2 = /* @__PURE__ */ new Map();
      const finalConfig = {
        ...config,
        output: platform === "browser" ? "dom" : "html",
        resolveVirtualDependency(from, dep) {
          virtualFiles2.set(path2.join(from, "..", dep.virtualPath), dep);
          return dep.virtualPath;
        }
      };
      const scanConfig = {
        ...finalConfig,
        output: "hydrate"
      };
      build.onResolve({ filter: /\.marko\./ }, (args) => {
        return {
          namespace: "marko:virtual",
          path: path2.resolve(args.resolveDir, args.path),
          external: isScan
        };
      });
      build.onLoad(
        { filter: /\.marko\./, namespace: "marko:virtual" },
        (args) => ({
          contents: virtualFiles2.get(args.path).code,
          loader: path2.extname(args.path).slice(1)
        })
      );
      build.onLoad({ filter: /\.marko$/ }, async (args) => {
        try {
          const { code, meta } = await compiler.compileFile(
            args.path,
            isScan && args.namespace === "" ? scanConfig : finalConfig
          );
          return {
            loader: "js",
            contents: code,
            watchFiles: meta.watchFiles,
            resolveDir: path2.dirname(args.path)
          };
        } catch (e) {
          const text = e.message;
          const errors = [];
          let match;
          let lines;
          while (match = markoErrorRegExp.exec(text)) {
            const [, file, rawLine, rawCol, text2] = match;
            const line = parseInt(rawLine, 10) || 1;
            const column = parseInt(rawCol, 10) || 1;
            lines ||= (await fs.promises.readFile(args.path, "utf-8")).split(
              /\n/g
            );
            errors.push({
              text: text2,
              location: {
                file,
                line,
                column,
                lineText: ` ${lines[line - 1]}`
              }
            });
          }
          if (!errors.length) {
            errors.push({ text });
          }
          return {
            errors
          };
        }
      });
    }
  };
}

// src/babel-plugin-cjs-interop.ts
import * as t from "@babel/types";

// src/resolve.ts
import { exports } from "resolve.exports";
import Resolve from "resolve";
import path3 from "path";
import fs2 from "fs";
var exportsMainFile = `__package_exports__`;
var modulePathReg = /^.*[/\\]node_modules[/\\](?:@[^/\\]+[/\\])?[^/\\]+[/\\]/;
var cjsModuleLookup = /* @__PURE__ */ new Map();
function isCJSModule(id) {
  const modulePath = modulePathReg.exec(id)?.[0];
  if (modulePath) {
    const pkgPath = modulePath + "package.json";
    let isCJS = cjsModuleLookup.get(pkgPath);
    if (isCJS === void 0) {
      try {
        const pkg = JSON.parse(fs2.readFileSync(pkgPath, "utf8"));
        isCJS = pkg.type !== "module" && !pkg.exports;
      } catch {
        isCJS = false;
      }
      cjsModuleLookup.set(pkgPath, isCJS);
    }
    return isCJS;
  }
  return false;
}
function resolve(id, from, extensions, conditions) {
  return Resolve.sync(id, {
    basedir: path3.dirname(from),
    filename: from,
    pathFilter,
    packageFilter,
    extensions
  });
  function pathFilter(pkg, pkgFile, relativePath) {
    cjsModuleLookup.set(pkgFile, pkg.type !== "module" && !pkg.exports);
    if (pkg.exports) {
      return exports(
        pkg,
        relativePath === exportsMainFile ? "." : relativePath,
        {
          conditions
        }
      )?.[0];
    }
    return relativePath;
  }
}
function packageFilter(pkg) {
  if (pkg.exports) {
    pkg.main = exportsMainFile;
  }
  return pkg;
}

// src/babel-plugin-cjs-interop.ts
function plugin(options) {
  return {
    name: "marko-import-interop",
    visitor: {
      ImportDeclaration(path7) {
        if (!path7.node.specifiers.length || /\.(?:mjs|marko)$|\?/.test(path7.node.source.value) || options.filter?.(path7.node.source.value) === false) {
          return;
        }
        try {
          const resolved = resolve(
            path7.node.source.value,
            path7.hub.file.opts.filename,
            options.extensions,
            options.conditions
          );
          if (!/\.c?js$/.test(resolved) || !isCJSModule(resolved)) {
            return;
          }
        } catch (_) {
          return;
        }
        let namespaceId;
        let defaultImportId;
        let imports;
        for (const s of path7.node.specifiers) {
          if (t.isImportSpecifier(s)) {
            (imports ||= []).push({
              name: t.isStringLiteral(s.imported) ? s.imported.value : s.imported.name,
              alias: s.local.name
            });
          } else if (t.isImportDefaultSpecifier(s)) {
            defaultImportId = s.local;
          } else if (t.isImportNamespaceSpecifier(s)) {
            namespaceId = s.local;
          }
        }
        namespaceId ||= path7.scope.generateUidIdentifier(
          defaultImportId?.name || path7.node.source.value
        );
        path7.node.specifiers = [t.importDefaultSpecifier(namespaceId)];
        if (defaultImportId) {
          path7.insertAfter(
            t.variableDeclaration("const", [
              t.variableDeclarator(
                defaultImportId,
                t.conditionalExpression(
                  t.optionalMemberExpression(
                    namespaceId,
                    t.identifier("__esModule"),
                    false,
                    true
                  ),
                  t.memberExpression(namespaceId, t.identifier("default")),
                  namespaceId
                )
              )
            ])
          );
        }
        if (imports) {
          path7.insertAfter(
            t.variableDeclaration("const", [
              t.variableDeclarator(
                t.objectPattern(
                  imports.map(
                    ({ name, alias }) => t.objectProperty(
                      t.identifier(name),
                      t.identifier(alias),
                      false,
                      name === alias
                    )
                  )
                ),
                namespaceId
              )
            ])
          );
        }
      }
    }
  };
}

// src/render-assets-transform.ts
var render_assets_transform_default = (tag, t3) => {
  if (tag.hub.file.markoOpts.markoViteLinked) {
    const body = tag.get("body");
    const tagName = tag.get("name").node.value;
    body.unshiftContainer("body", renderAssetsCall(t3, `${tagName}-prepend`));
    body.pushContainer("body", renderAssetsCall(t3, tagName));
  }
};
function renderAssetsCall(t3, slot) {
  return t3.markoPlaceholder(
    t3.callExpression(
      t3.memberExpression(
        t3.memberExpression(t3.identifier("out"), t3.identifier("global")),
        t3.identifier("___viteRenderAssets")
      ),
      [t3.stringLiteral(slot)]
    ),
    false
  );
}

// src/relative-assets-transform.ts
var attrSrc = /* @__PURE__ */ new Set(["src"]);
var attrHref = /* @__PURE__ */ new Set(["href"]);
var assetAttrsByTag = /* @__PURE__ */ new Map([
  ["audio", attrSrc],
  ["embed", attrSrc],
  ["iframe", attrSrc],
  ["img", /* @__PURE__ */ new Set(["src", "srcset"])],
  ["input", attrSrc],
  ["source", attrSrc],
  ["track", attrSrc],
  ["video", /* @__PURE__ */ new Set(["src", "poster"])],
  ["a", attrHref],
  ["area", attrHref],
  ["link", attrHref],
  ["object", /* @__PURE__ */ new Set(["data"])],
  ["body", /* @__PURE__ */ new Set(["background"])],
  ["script", /* @__PURE__ */ new Set(["src"])]
]);
var assetFileReg = /(?:^\..*\.(?:a?png|jpe?g|jfif|pipeg|pjp|gif|svg|ico|web[pm]|avif|mp4|ogg|mp3|wav|flac|aac|opus|woff2?|eot|[ot]tf|webmanifest|pdf|txt)(\?|$)|\?url\b)/;
function transform(tag, t3) {
  const { name, attributes } = tag.node;
  if (name.type !== "StringLiteral") {
    return;
  }
  const assetAttrs = assetAttrsByTag.get(name.value);
  if (!assetAttrs) {
    return;
  }
  for (const attr of attributes) {
    if (attr.type === "MarkoAttribute" && attr.value.type === "StringLiteral" && assetAttrs.has(attr.name)) {
      const { value } = attr.value;
      if (assetFileReg.test(value)) {
        const importedId = tag.scope.generateUid(value);
        attr.value = t3.identifier(importedId);
        tag.hub.file.path.unshiftContainer(
          "body",
          t3.importDeclaration(
            [t3.importDefaultSpecifier(t3.identifier(importedId))],
            t3.stringLiteral(value)
          )
        );
      }
    }
  }
}

// src/glob-import-transform.ts
import { types as t2 } from "@marko/compiler";
import glob from "fast-glob";
import path4 from "path";
var programGlobImports = /* @__PURE__ */ new WeakMap();
var glob_import_transform_default = {
  MetaProperty(tag) {
    const memberExpression2 = tag.parentPath;
    if (memberExpression2.node.type === "MemberExpression" && memberExpression2.node.property.type === "Identifier" && memberExpression2.node.property.name === "glob") {
      const callExpression = memberExpression2.parentPath;
      if (callExpression?.node.type === "CallExpression") {
        const args = callExpression.get("arguments").map((arg) => arg.evaluate().value);
        if (args[1]?.eager) {
          const program = tag.hub.file.path;
          const existing = programGlobImports.get(program);
          if (!existing) {
            programGlobImports.set(program, [args]);
          } else {
            existing.push(args);
          }
        }
      }
    }
  },
  Program: {
    exit(tag) {
      const globImports = programGlobImports.get(tag);
      if (!globImports) {
        return;
      }
      const { cwd, filename } = tag.hub.file.opts;
      const dir = path4.dirname(filename);
      const seen = /* @__PURE__ */ new Set();
      for (const [patterns, options] of globImports) {
        const resolvedPatterns = Array.isArray(patterns) ? patterns.map((p) => path4.resolve(dir, p)) : path4.resolve(dir, patterns);
        const results = glob.globSync(resolvedPatterns, {
          cwd,
          absolute: true,
          dot: !!options.exhaustive,
          ignore: options.exhaustive ? [] : [path4.join(cwd, "**/node_modules/**")]
        });
        for (const file of results) {
          if (file.endsWith(".marko") && file !== filename && !seen.has(file)) {
            seen.add(file);
            tag.node.body.push(t2.importDeclaration([], t2.stringLiteral(file)));
          }
        }
      }
    }
  }
};

// src/read-once-persisted-store.ts
import os from "os";
import path5 from "path";
import { promises as fs3 } from "fs";
var noop = () => {
};
var tmpFile = path5.join(os.tmpdir(), "marko-vite-storage.json");
var values = /* @__PURE__ */ new Map();
var loadedFromDisk;
var ReadOncePersistedStore = class {
  constructor(uid) {
    this.uid = uid;
  }
  write(value) {
    values.set(this.uid, value);
  }
  async read() {
    const { uid } = this;
    if (values.has(uid)) {
      const value = values.get(uid);
      values.delete(uid);
      return value;
    }
    if (loadedFromDisk === true) {
      throw new Error(`Value for ${uid} could not be loaded.`);
    }
    await (loadedFromDisk ||= fs3.readFile(tmpFile, "utf-8").then(syncDataFromDisk).catch(finishLoadFromDisk));
    return this.read();
  }
};
function syncDataFromDisk(data) {
  finishLoadFromDisk();
  fs3.unlink(tmpFile).catch(noop);
  for (const [k, v] of JSON.parse(data)) {
    values.set(k, v);
  }
}
function finishLoadFromDisk() {
  loadedFromDisk = true;
}
process.once("beforeExit", (code) => {
  if (code === 0 && values.size) {
    fs3.writeFile(tmpFile, JSON.stringify([...values])).catch(noop);
  }
});

// src/index.ts
var POSIX_SEP = "/";
var WINDOWS_SEP = "\\";
var normalizePath = path6.sep === WINDOWS_SEP ? (id) => id.replace(/\\/g, POSIX_SEP) : (id) => id;
var virtualFiles = /* @__PURE__ */ new Map();
var extReg = /\.[^.]+$/;
var queryReg = /\?marko-[^?]+$/;
var browserEntryQuery = "?marko-browser-entry";
var serverEntryQuery = "?marko-server-entry";
var virtualFileQuery = "?marko-virtual";
var browserQuery = "?marko-browser";
var markoExt = ".marko";
var htmlExt = ".html";
var resolveOpts = { skipSelf: true };
var configsByFileSystem = /* @__PURE__ */ new Map();
var cache = /* @__PURE__ */ new Map();
var babelCaller = {
  name: "@marko/vite",
  supportsStaticESM: true,
  supportsDynamicImport: true,
  supportsTopLevelAwait: true,
  supportsExportNamespaceFrom: true
};
var registeredTagLib = false;
var cjsToEsm;
function markoPlugin(opts = {}) {
  let compiler;
  let { linked = true } = opts;
  let runtimeId;
  let basePathVar;
  let baseConfig;
  let ssrConfig;
  let ssrCjsConfig;
  let domConfig;
  let hydrateConfig;
  const resolveVirtualDependency = (from, dep) => {
    const normalizedFrom = normalizePath(from);
    const query = `${virtualFileQuery}&id=${Buffer.from(dep.virtualPath).toString("base64url") + path6.extname(dep.virtualPath)}`;
    const id = normalizePath(normalizedFrom) + query;
    if (devServer) {
      const prev = virtualFiles.get(id);
      if (isDeferredPromise(prev)) {
        prev.resolve(dep);
      }
    }
    virtualFiles.set(id, dep);
    return `./${path6.posix.basename(normalizedFrom) + query}`;
  };
  let root;
  let devEntryFile;
  let devEntryFilePosix;
  let renderAssetsRuntimeCode;
  let isTest = false;
  let isBuild = false;
  let isSSRBuild = false;
  let devServer;
  let serverManifest;
  let basePath = "/";
  let getMarkoAssetFns;
  const entryIds = /* @__PURE__ */ new Set();
  const cachedSources = /* @__PURE__ */ new Map();
  const transformWatchFiles = /* @__PURE__ */ new Map();
  const transformOptionalFiles = /* @__PURE__ */ new Map();
  const store = new ReadOncePersistedStore(
    `vite-marko${runtimeId ? `-${runtimeId}` : ""}`
  );
  return [
    {
      name: "marko-vite:pre",
      enforce: "pre",
      // Must be pre to allow us to resolve assets before vite.
      async config(config, env) {
        let optimize = env.mode === "production";
        if ("MARKO_DEBUG" in process.env) {
          optimize = process.env.MARKO_DEBUG === "false" || process.env.MARKO_DEBUG === "0";
        } else {
          process.env.MARKO_DEBUG = optimize ? "false" : "true";
        }
        compiler ??= await import(opts.compiler || "@marko/compiler");
        runtimeId = opts.runtimeId;
        basePathVar = opts.basePathVar;
        if ("BASE_URL" in process.env && config.base == null) {
          config.base = process.env.BASE_URL;
        }
        baseConfig = {
          cache,
          optimize,
          // optimizedRegistryIds:
          //   optimize && linked ? optimizedRegistryIds : undefined,
          runtimeId,
          sourceMaps: true,
          writeVersionComment: false,
          babelConfig: opts.babelConfig ? {
            ...opts.babelConfig,
            caller: opts.babelConfig.caller ? {
              name: "@marko/vite",
              supportsStaticESM: true,
              supportsDynamicImport: true,
              supportsTopLevelAwait: true,
              supportsExportNamespaceFrom: true,
              ...opts.babelConfig.caller
            } : babelCaller
          } : {
            babelrc: false,
            configFile: false,
            browserslistConfigFile: false,
            caller: babelCaller
          }
        };
        if (linked) {
          baseConfig.markoViteLinked = linked;
        }
        ssrConfig = {
          ...baseConfig,
          resolveVirtualDependency,
          output: "html"
        };
        domConfig = {
          ...baseConfig,
          resolveVirtualDependency,
          output: "dom"
        };
        hydrateConfig = {
          ...baseConfig,
          resolveVirtualDependency,
          output: "hydrate"
        };
        compiler.configure(baseConfig);
        root = normalizePath(config.root || process.cwd());
        devEntryFile = path6.join(root, "index.html");
        devEntryFilePosix = normalizePath(devEntryFile);
        isTest = env.mode === "test";
        isBuild = env.command === "build";
        isSSRBuild = isBuild && linked && Boolean(config.build.ssr);
        renderAssetsRuntimeCode = getRenderAssetsRuntime({
          isBuild,
          basePathVar,
          runtimeId
        });
        if (isTest) {
          linked = false;
          const { test } = config;
          if (test.environment?.includes("dom")) {
            config.resolve ??= {};
            config.resolve.conditions ??= [];
            config.resolve.conditions.push("browser");
            test.deps ??= {};
            test.deps.optimizer ??= {};
            test.deps.optimizer.web ??= {};
            test.deps.optimizer.web.enabled ??= true;
          }
        }
        if (!registeredTagLib) {
          registeredTagLib = true;
          compiler.taglib.register("@marko/vite", {
            transform: glob_import_transform_default,
            "<head>": { transformer: render_assets_transform_default },
            "<body>": { transformer: render_assets_transform_default },
            "<*>": { transformer: transform }
          });
        }
        const optimizeDeps = config.optimizeDeps ??= {};
        if (!isTest) {
          optimizeDeps.entries ??= [
            "**/*.marko",
            "!**/__snapshots__/**",
            `!**/__tests__/**`,
            `!**/coverage/**`
          ];
        }
        const domDeps = compiler.getRuntimeEntryFiles("dom", opts.translator);
        optimizeDeps.include = optimizeDeps.include ? [...optimizeDeps.include, ...domDeps] : domDeps;
        const optimizeExtensions = optimizeDeps.extensions ??= [];
        optimizeExtensions.push(".marko");
        const esbuildOptions = optimizeDeps.esbuildOptions ??= {};
        const esbuildPlugins = esbuildOptions.plugins ??= [];
        esbuildPlugins.push(esbuildPlugin(compiler, baseConfig));
        const ssr = config.ssr ??= {};
        const { noExternal } = ssr;
        if (noExternal !== true) {
          const noExternalReg = /\.marko$/;
          if (noExternal) {
            if (Array.isArray(noExternal)) {
              ssr.noExternal = [...noExternal, noExternalReg];
            } else {
              ssr.noExternal = [noExternal, noExternalReg];
            }
          } else {
            ssr.noExternal = noExternalReg;
          }
        }
        if (isSSRBuild && !config.build?.rollupOptions?.output) {
          config.build ??= {};
          config.build.rollupOptions ??= {};
          config.build.rollupOptions.output = {
            chunkFileNames: `[name]-[hash].js`
          };
        }
        if (basePathVar) {
          config.experimental ??= {};
          if (config.experimental.renderBuiltUrl) {
            throw new Error(
              "Cannot use @marko/vite `basePathVar` with Vite's `renderBuiltUrl` option."
            );
          }
          const assetsDir = config.build?.assetsDir?.replace(/[/\\]$/, "") ?? "assets";
          const assetsDirLen = assetsDir.length;
          const assetsDirEnd = assetsDirLen + 1;
          const trimAssertsDir = (fileName) => {
            if (fileName.startsWith(assetsDir)) {
              switch (fileName[assetsDirLen]) {
                case POSIX_SEP:
                case WINDOWS_SEP:
                  return fileName.slice(assetsDirEnd);
              }
            }
            return fileName;
          };
          config.experimental.renderBuiltUrl = (fileName, { hostType, ssr: ssr2 }) => {
            switch (hostType) {
              case "html":
                return trimAssertsDir(fileName);
              case "js":
                return {
                  runtime: `${ssr2 ? basePathVar : `$mbp${runtimeId ? `_${runtimeId}` : ""}`}+${JSON.stringify(trimAssertsDir(fileName))}`
                };
              default:
                return { relative: true };
            }
          };
        }
        return {
          resolve: {
            alias: [
              {
                find: /^~(?!\/)/,
                replacement: ""
              }
            ]
          }
        };
      },
      configResolved(config) {
        basePath = config.base;
        ssrCjsConfig = {
          ...ssrConfig,
          babelConfig: {
            ...ssrConfig.babelConfig,
            plugins: (ssrConfig.babelConfig.plugins || []).concat(
              plugin({
                extensions: config.resolve.extensions,
                conditions: config.resolve.conditions,
                filter: isBuild ? void 0 : (path7) => !/^\./.test(path7)
              })
            )
          }
        };
        getMarkoAssetFns = void 0;
        for (const plugin2 of config.plugins) {
          const fn = plugin2.api?.getMarkoAssetCodeForEntry;
          if (fn) {
            if (getMarkoAssetFns) {
              getMarkoAssetFns.push(fn);
            } else {
              getMarkoAssetFns = [fn];
            }
          }
        }
      },
      configureServer(_server) {
        ssrConfig.hot = domConfig.hot = true;
        devServer = _server;
        devServer.watcher.on("all", (type, originalFileName) => {
          const fileName = normalizePath(originalFileName);
          cachedSources.delete(fileName);
          if (type === "unlink") {
            entryIds.delete(fileName);
            transformWatchFiles.delete(fileName);
            transformOptionalFiles.delete(fileName);
          }
          for (const [id, files] of transformWatchFiles) {
            if (anyMatch(files, fileName)) {
              devServer.watcher.emit("change", id);
            }
          }
          if (type === "add" || type === "unlink") {
            for (const [id, files] of transformOptionalFiles) {
              if (anyMatch(files, fileName)) {
                devServer.watcher.emit("change", id);
              }
            }
          }
        });
      },
      handleHotUpdate(ctx) {
        compiler.taglib.clearCaches();
        baseConfig.cache.clear();
        for (const [, cache2] of configsByFileSystem) {
          cache2.clear();
        }
        for (const mod of ctx.modules) {
          if (mod.id && virtualFiles.has(mod.id)) {
            virtualFiles.set(mod.id, createDeferredPromise());
          }
        }
      },
      async buildStart(inputOptions) {
        if (isBuild && linked && !isSSRBuild) {
          try {
            serverManifest = await store.read();
            inputOptions.input = toHTMLEntries(root, serverManifest.entries);
            for (const entry in serverManifest.entrySources) {
              const id = normalizePath(path6.resolve(root, entry));
              entryIds.add(id);
              cachedSources.set(id, serverManifest.entrySources[entry]);
            }
          } catch (err) {
            this.error(
              `You must run the "ssr" build before the "browser" build.`
            );
          }
          if (isEmpty(inputOptions.input)) {
            this.error("No Marko files were found when compiling the server.");
          }
        }
      },
      async resolveId(importee, importer, importOpts, ssr = importOpts.ssr) {
        if (virtualFiles.has(importee)) {
          return importee;
        }
        if (importee === renderAssetsRuntimeId) {
          return { id: renderAssetsRuntimeId };
        }
        let importeeQuery = getMarkoQuery(importee);
        if (importeeQuery) {
          importee = importee.slice(0, -importeeQuery.length);
        } else if (!importOpts.scan) {
          if (ssr && linked && importer && importer[0] !== "\0" && (importer !== devEntryFile || normalizePath(importer) !== devEntryFilePosix) && // Vite tries to resolve against an `index.html` in some cases, we ignore it here.
          isMarkoFile(importee) && !isMarkoFile(importer.replace(queryReg, ""))) {
            importeeQuery = serverEntryQuery;
          } else if (!ssr && isBuild && importer && isMarkoFile(importee) && this.getModuleInfo(importer)?.isEntry) {
            importeeQuery = browserEntryQuery;
          } else if (!isBuild && linked && !ssr && !importeeQuery && isMarkoFile(importee)) {
            importeeQuery = browserQuery;
          }
        }
        if (importeeQuery) {
          const resolved = importee[0] === "." ? {
            id: normalizePath(
              importer ? path6.resolve(importer, "..", importee) : path6.resolve(root, importee)
            )
          } : await this.resolve(importee, importer, resolveOpts);
          if (resolved) {
            resolved.id += importeeQuery;
          }
          return resolved;
        }
        if (importer) {
          const importerQuery = getMarkoQuery(importer);
          if (importerQuery) {
            importer = importer.slice(0, -importerQuery.length);
            if (importee[0] === ".") {
              const resolved = normalizePath(
                path6.resolve(importer, "..", importee)
              );
              if (resolved === normalizePath(importer)) return resolved;
            }
            return this.resolve(importee, importer, resolveOpts);
          }
        }
        return null;
      },
      async load(rawId) {
        const id = stripVersionAndTimeStamp(rawId);
        if (id === renderAssetsRuntimeId) {
          return renderAssetsRuntimeCode;
        }
        const query = getMarkoQuery(id);
        switch (query) {
          case serverEntryQuery: {
            entryIds.add(id.slice(0, -query.length));
            return null;
          }
          case browserEntryQuery:
          case browserQuery: {
            return cachedSources.get(id.slice(0, -query.length)) || null;
          }
        }
        return virtualFiles.get(id) || null;
      },
      async transform(source, rawId, ssr) {
        let id = stripVersionAndTimeStamp(rawId);
        const info = isBuild ? this.getModuleInfo(id) : void 0;
        const arcSourceId = info?.meta.arcSourceId;
        if (arcSourceId) {
          const arcFlagSet = info.meta.arcFlagSet;
          id = arcFlagSet ? arcSourceId.replace(extReg, `[${arcFlagSet.join("+")}]$&`) : arcSourceId;
        }
        const isSSR = typeof ssr === "object" ? ssr.ssr : ssr;
        const query = getMarkoQuery(id);
        if (query && !query.startsWith(virtualFileQuery)) {
          id = id.slice(0, -query.length);
          if (query === serverEntryQuery) {
            const fileName = id;
            let mainEntryData;
            id = `${id.slice(0, -markoExt.length)}.entry.marko`;
            cachedSources.set(fileName, source);
            if (isBuild) {
              const relativeFileName = path6.posix.relative(root, fileName);
              const entryId = toEntryId(relativeFileName);
              serverManifest ??= {
                entries: {},
                entrySources: {},
                chunksNeedingAssets: []
              };
              serverManifest.entries[entryId] = relativeFileName;
              serverManifest.entrySources[relativeFileName] = source;
              mainEntryData = JSON.stringify(entryId);
            } else {
              mainEntryData = JSON.stringify(
                await generateDocManifest(
                  basePath,
                  await devServer.transformIndexHtml(
                    "/",
                    generateInputDoc(
                      posixFileNameToURL(fileName, root) + browserEntryQuery
                    )
                  )
                )
              );
            }
            const entryData = [mainEntryData];
            if (getMarkoAssetFns) {
              for (const getMarkoAsset of getMarkoAssetFns) {
                const asset = getMarkoAsset(fileName);
                if (asset) {
                  entryData.push(asset);
                }
              }
            }
            source = await server_entry_template_default({
              fileName,
              entryData,
              runtimeId,
              basePathVar: isBuild ? basePathVar : void 0
            });
          }
        }
        if (!isMarkoFile(id)) {
          if (!isBuild) {
            const ext = path6.extname(id);
            if (ext === ".cjs" || ext === ".js" && isCJSModule(id)) {
              if (cjsToEsm === void 0) {
                try {
                  cjsToEsm = (await import("@chialab/cjs-to-esm")).transform;
                } catch {
                  cjsToEsm = null;
                  return null;
                }
              }
              if (cjsToEsm) {
                try {
                  return await cjsToEsm(source);
                } catch {
                  return null;
                }
              }
            }
          }
          return null;
        }
        if (isSSR) {
          if (linked) {
            cachedSources.set(id, source);
          }
          if (!query && isCJSModule(id)) {
            if (isBuild) {
              const { code: code2, map: map2, meta: meta2 } = await compiler.compile(
                source,
                id,
                getConfigForFileSystem(info, ssrCjsConfig)
              );
              return {
                code: code2,
                map: map2,
                meta: { arcSourceCode: source, arcScanIds: meta2.analyzedTags }
              };
            }
          }
        }
        const compiled = await compiler.compile(
          source,
          id,
          getConfigForFileSystem(
            info,
            isSSR ? isCJSModule(id) ? ssrCjsConfig : ssrConfig : query === browserEntryQuery ? hydrateConfig : domConfig
          )
        );
        const { map, meta } = compiled;
        let { code } = compiled;
        if (query !== browserEntryQuery && devServer) {
          code += `
if (import.meta.hot) import.meta.hot.accept(() => {});`;
        }
        if (devServer) {
          const templateName = getPosixBasenameWithoutExt(id);
          const optionalFilePrefix = path6.dirname(id) + path6.sep + (templateName === "index" ? "" : `${templateName}.`);
          for (const file of meta.watchFiles) {
            this.addWatchFile(file);
          }
          transformOptionalFiles.set(id, [
            `${optionalFilePrefix}style.*`,
            `${optionalFilePrefix}component.*`,
            `${optionalFilePrefix}component-browser.*`,
            `${optionalFilePrefix}marko-tag.json`
          ]);
          transformWatchFiles.set(id, meta.watchFiles);
        }
        return {
          code,
          map,
          meta: isBuild ? { arcSourceCode: source, arcScanIds: meta.analyzedTags } : void 0
        };
      }
    },
    {
      name: "marko-vite:post",
      apply: "build",
      enforce: "post",
      // We use a "post" plugin to allow us to read the final generated `.html` from vite.
      async generateBundle(outputOptions, bundle, isWrite) {
        if (!linked) {
          return;
        }
        if (!isWrite) {
          this.error(
            `Linked builds are currently only supported when in "write" mode.`
          );
        }
        if (!serverManifest) {
          this.error(
            "No Marko files were found when bundling the server in linked mode."
          );
        }
        if (isSSRBuild) {
          const dir = outputOptions.dir ? path6.resolve(outputOptions.dir) : path6.resolve(outputOptions.file, "..");
          for (const fileName in bundle) {
            const chunk = bundle[fileName];
            if (chunk.type === "chunk") {
              if (chunk.moduleIds.includes(renderAssetsRuntimeId)) {
                serverManifest.chunksNeedingAssets.push(
                  path6.resolve(dir, fileName)
                );
              }
            }
          }
          store.write(serverManifest);
        } else {
          const browserManifest = {};
          for (const entryId in serverManifest.entries) {
            const fileName = serverManifest.entries[entryId];
            const chunkId = fileName + htmlExt;
            const chunk = bundle[chunkId];
            if (chunk?.type === "asset") {
              browserManifest[entryId] = {
                ...await generateDocManifest(
                  basePath,
                  chunk.source.toString()
                ),
                preload: void 0
                // clear out preload for prod builds.
              };
              delete bundle[chunkId];
            } else {
              this.error(
                `Marko template had unexpected output from vite, ${fileName}`
              );
            }
          }
          const manifestStr = `;var __MARKO_MANIFEST__=${JSON.stringify(
            browserManifest
          )};
`;
          for (const fileName of serverManifest.chunksNeedingAssets) {
            await fs4.promises.appendFile(fileName, manifestStr);
          }
        }
      }
    }
  ];
}
function getMarkoQuery(id) {
  return queryReg.exec(id)?.[0] || "";
}
function isMarkoFile(id) {
  return id.endsWith(markoExt);
}
function toHTMLEntries(root, serverEntries) {
  const result = [];
  for (const id in serverEntries) {
    const markoFile = path6.posix.join(root, serverEntries[id]);
    const htmlFile = markoFile + htmlExt;
    virtualFiles.set(htmlFile, {
      code: generateInputDoc(markoFile + browserEntryQuery)
    });
    result.push(htmlFile);
  }
  return result;
}
function toEntryId(id) {
  const lastSepIndex = id.lastIndexOf(POSIX_SEP);
  let name = id.slice(lastSepIndex + 1, id.indexOf(".", lastSepIndex));
  if (name === "index" || name === "template") {
    name = id.slice(
      id.lastIndexOf(POSIX_SEP, lastSepIndex - 1) + 1,
      lastSepIndex
    );
  }
  return `${name}_${crypto.createHash("SHA1").update(id).digest("base64").replace(/[/+]/g, "-").slice(0, 4)}`;
}
function posixFileNameToURL(fileName, root) {
  const relativeURL = path6.posix.relative(
    pathToFileURL(root).pathname,
    pathToFileURL(fileName).pathname
  );
  if (relativeURL[0] === ".") {
    throw new Error(
      "@marko/vite: Entry templates must exist under the current root directory."
    );
  }
  return `/${relativeURL}`;
}
function getPosixBasenameWithoutExt(file) {
  const baseStart = file.lastIndexOf(POSIX_SEP) + 1;
  const extStart = file.indexOf(".", baseStart + 1);
  return file.slice(baseStart, extStart);
}
function createDeferredPromise() {
  let resolve2;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve2 = res;
    reject = rej;
  });
  promise.resolve = resolve2;
  promise.reject = reject;
  return promise;
}
function isDeferredPromise(obj) {
  return typeof obj?.then === "function";
}
function isEmpty(obj) {
  for (const _ in obj) {
    return false;
  }
  return true;
}
function stripVersionAndTimeStamp(id) {
  const queryStart = id.indexOf("?");
  if (queryStart === -1) return id;
  const url = id.slice(0, queryStart);
  const query = id.slice(queryStart + 1).replace(/(?:^|[&])[vt]=[^&]+/g, "");
  if (query) return `${url}?${query}`;
  return url;
}
function getConfigForFileSystem(info, config) {
  const fileSystem = info?.meta.arcFS;
  if (!fileSystem) return config;
  let configsForFileSystem = configsByFileSystem.get(fileSystem);
  if (!configsForFileSystem) {
    configsForFileSystem = /* @__PURE__ */ new Map();
    configsByFileSystem.set(fileSystem, configsForFileSystem);
  }
  let configForFileSystem = configsForFileSystem.get(config);
  if (!configForFileSystem) {
    configForFileSystem = {
      ...config,
      fileSystem,
      cache: configsForFileSystem
    };
    configsForFileSystem.set(config, configForFileSystem);
  }
  return configForFileSystem;
}
export {
  markoPlugin as default
};
