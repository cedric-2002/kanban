"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/adapter/index.ts
var adapter_exports = {};
__export(adapter_exports, {
  createDevServer: () => createDevServer,
  createErrorMiddleware: () => createErrorMiddleware,
  createViteDevServer: () => createViteDevServer,
  default: () => adapter,
  getDevGlobal: () => getDevGlobal
});
module.exports = __toCommonJS(adapter_exports);

// scripts/importMetaURL.js
var import_url = require("url");
var __importMetaURL = (0, import_url.pathToFileURL)(__filename);

// src/adapter/index.ts
var import_run_explorer = require("@marko/run-explorer");
var import_fs2 = __toESM(require("fs"), 1);
var import_inspector2 = __toESM(require("inspector"), 1);
var import_path2 = __toESM(require("path"), 1);
var import_url2 = require("url");

// src/vite/utils/server.ts
var import_child_process = __toESM(require("child_process"), 1);
var import_cluster = __toESM(require("cluster"), 1);
var import_dotenv = require("dotenv");
var import_fs = __toESM(require("fs"), 1);
var import_net = __toESM(require("net"), 1);
async function parseEnv(envFile) {
  if (import_fs.default.existsSync(envFile)) {
    const content = await import_fs.default.promises.readFile(envFile, "utf8");
    return (0, import_dotenv.parse)(content);
  }
}
function loadEnv(envFile) {
  (0, import_dotenv.config)({ path: envFile });
}
async function spawnServer(cmd, args = [], port = 0, env, cwd = process.cwd(), wait = 3e4, stdio = ["ignore", "inherit", "inherit"]) {
  if (port <= 0) {
    port = await getAvailablePort();
  }
  if (typeof env === "string") {
    env = await parseEnv(env);
  }
  const proc = import_child_process.default.spawn(cmd, args, {
    cwd,
    shell: true,
    stdio,
    windowsHide: true,
    env: { ...env, NODE_ENV: "development", ...process.env, PORT: `${port}` }
  });
  const close = () => {
    proc.unref();
    proc.kill();
  };
  try {
    await Promise.race([waitForError(proc, port), waitForServer(port, wait)]);
  } catch (err) {
    close();
    throw err;
  }
  return {
    port,
    close
  };
}
async function spawnServerWorker(module2, args = [], port = 0, env, wait = true) {
  if (port <= 0) {
    port = await getAvailablePort();
  }
  if (typeof env === "string") {
    env = await parseEnv(env);
  }
  const originalExec = import_cluster.default.settings.exec;
  const originalArgs = import_cluster.default.settings.execArgv;
  try {
    import_cluster.default.settings.exec = module2;
    import_cluster.default.settings.execArgv = args;
    const worker = import_cluster.default.fork({
      ...env,
      NODE_ENV: "development",
      ...process.env,
      PORT: `${port}`
    });
    if (wait) {
      return new Promise((resolve) => {
        function ready(message) {
          if (message === "ready") {
            worker.off("message", ready);
            resolve(worker);
          }
        }
        worker.on("message", ready);
      });
    }
    return worker;
  } finally {
    import_cluster.default.settings.exec = originalExec;
    import_cluster.default.settings.execArgv = originalArgs;
  }
}
async function waitForError(proc, port) {
  return new Promise((_, reject) => {
    proc.once("error", reject);
    proc.once("exit", (code) => {
      reject(
        new Error(
          `Process exited with code ${code} while waiting for server to start on port "${port}".`
        )
      );
    });
  });
}
async function waitForServer(port, wait = 0) {
  let remaining = wait > 0 ? wait : Infinity;
  let connection;
  while (!(connection = await getConnection(port))) {
    if (remaining >= 100) {
      remaining -= 100;
      await sleep(100);
    } else {
      throw new Error(
        `Timeout while wating for server to start on port "${port}".`
      );
    }
  }
  return connection;
}
async function waitForWorker(worker, port) {
  return new Promise((resolve, reject) => {
    function listening(address) {
      if (address.port === port) {
        worker.off("listening", listening);
        resolve();
      }
    }
    worker.on("listening", listening).once("error", reject).once("exit", (code) => {
      reject(
        new Error(
          `Worker exited with code ${code} while waiting for dev server to start on port "${port}".`
        )
      );
    });
  });
}
async function getConnection(port) {
  return new Promise((resolve) => {
    const connection = import_net.default.connect(port).setNoDelay(true).setKeepAlive(false).on("error", () => {
      connection.end();
      resolve(null);
    }).on("connect", () => {
      resolve(connection);
    });
  });
}
async function isPortInUse(port) {
  return Boolean(await getConnection(port));
}
async function getAvailablePort(port) {
  if (port && !await isPortInUse(port)) {
    return port;
  }
  return new Promise((resolve) => {
    const server = import_net.default.createServer().listen(0, () => {
      const { port: port2 } = server.address();
      server.close(() => resolve(port2));
    });
  });
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function getInspectOptions(args) {
  for (const arg of args) {
    const match = arg.match(/^--inspect(-brk)?(?:=(?:(.+):)?(.+))?$/);
    if (match) {
      return {
        host: match[2],
        port: parseInt(match[3], 10) || void 0,
        wait: !!match[1]
      };
    }
  }
}

// src/adapter/dev-server.ts
var import_path = __toESM(require("path"), 1);
var import_vite = require("vite");

// src/adapter/logger.ts
var import_draftlog = __toESM(require("draftlog"), 1);
var import_human_format = __toESM(require("human-format"), 1);
var import_inspector = __toESM(require("inspector"), 1);
var import_kleur = __toESM(require("kleur"), 1);
if (!import_inspector.default.url()) {
  import_draftlog.default.into(console);
  import_draftlog.default.defaults.canReWrite = false;
}
var HttpStatusColors = [
  "",
  // Unused
  "green",
  // 1xx
  "green",
  // 2xx
  "cyan",
  // 3xx
  "yellow",
  // 4xx
  "red"
  // 5xx
];
var IdChars = [
  "",
  import_kleur.default.cyan("\xB9"),
  import_kleur.default.magenta("\xB2"),
  import_kleur.default.green("\xB3"),
  import_kleur.default.red("\u2074"),
  import_kleur.default.cyan("\u2075"),
  import_kleur.default.magenta("\u2076"),
  import_kleur.default.green("\u2077"),
  import_kleur.default.red("\u2078"),
  import_kleur.default.cyan("\u2079"),
  import_kleur.default.red("\u207A")
];
var ArrowSteps = ["   ", "  \u25C0", " \u25C0\u2501", "\u25C0\u2501\u2501", "\u2501\u2501 ", "\u2501  ", "   "];
function logger_default(_options = {}) {
  let inFlight = 0;
  return function logger(req, res, next) {
    const startTime = Date.now();
    const handleFinish = () => done("finish");
    const handleClose = () => done("close");
    res.on("finish", handleFinish);
    res.on("close", handleClose);
    const bitMask = ~inFlight & inFlight + 1;
    const index = Math.log2(bitMask);
    const id = IdChars[index];
    if (index < IdChars.length) {
      inFlight |= bitMask;
    }
    const finalizeLog = logRequest(id, req);
    let bodyLength = 0;
    const _write = res.write;
    const _end = res.end;
    res.write = (...args) => {
      if (args[0]) {
        if (typeof args[1] !== "function") {
          bodyLength += Buffer.byteLength(args[0], args[1]);
        } else {
          bodyLength += args[0].length;
        }
      }
      return _write.apply(res, args);
    };
    res.end = (...args) => {
      if (args[0] && typeof args[0] !== "function") {
        if (typeof args[1] !== "function") {
          bodyLength += Buffer.byteLength(args[0], args[1]);
        } else {
          bodyLength += args[0].length;
        }
      }
      return _end.apply(res, args);
    };
    next == null ? void 0 : next();
    function done(event) {
      res.off("finish", handleFinish);
      res.off("close", handleClose);
      finalizeLog();
      if (index < 10) {
        inFlight ^= bitMask;
      }
      let contentLength = res.getHeader("content-length") || 0;
      if (Array.isArray(contentLength)) {
        contentLength = parseInt(contentLength[0], 10) || 0;
      } else if (typeof contentLength === "string") {
        contentLength = parseInt(contentLength, 10) || 0;
      }
      logResponse(
        id,
        req,
        res,
        startTime,
        contentLength || bodyLength,
        event === "finish"
      );
    }
  };
}
var spinners;
function logRequest(id, req) {
  const info = id + " " + import_kleur.default.bold(req.method) + " " + import_kleur.default.dim(req.url);
  const final = import_kleur.default.dim(requestArrow(id)) + info;
  if (console.draft) {
    spinners ?? (spinners = createAnimationManager({ steps: ArrowSteps.length }));
    const update = console.draft();
    const stop = spinners.add((step) => {
      update(import_kleur.default.cyan(requestArrow(id, step)) + info);
    });
    return () => {
      stop();
      update(final);
    };
  }
  console.log(final);
  return () => {
  };
}
function logResponse(id, req, res, startTime, contentLength, success) {
  const status = res.statusCode;
  const color = HttpStatusColors[status / 100 | 0] || "red";
  let length;
  if (req.method === "HEAD" || [204, 205, 304].includes(status)) {
    length = "";
  } else if (!contentLength) {
    length = import_kleur.default.dim("-");
  } else {
    length = formatMeasurement(bytes(contentLength));
  }
  let arrow = id ? "\u2501" : "\u2501\u2501";
  if (success) {
    arrow = import_kleur.default.dim(arrow + "\u25B6");
  } else {
    arrow = import_kleur.default.red(import_kleur.default.dim(arrow) + import_kleur.default.bold("x"));
  }
  console.log(
    arrow + id + " " + import_kleur.default.bold(req.method) + " " + import_kleur.default.dim(req.url) + " " + import_kleur.default[color](status) + " " + formatMeasurement(time(startTime)) + " " + length
  );
}
function requestArrow(id, step = 3) {
  const arrow = ArrowSteps[step];
  return id ? arrow.slice(0, -1) : arrow;
}
function time(start) {
  const delta = Date.now() - start;
  return delta < 5e3 ? [delta, "ms"] : [(delta / 1e3).toFixed(1), "s"];
}
function bytes(size) {
  const { value, prefix } = import_human_format.default.raw(size, { maxDecimals: 2, unit: "b" });
  return [value.toFixed(2), (prefix + "b").toLowerCase()];
}
function formatMeasurement([value, unit]) {
  return import_kleur.default.dim(value + import_kleur.default.yellow(import_kleur.default.bold(unit)));
}
function createAnimationManager(options = {}) {
  const { steps = 1e4, ms = 100 } = options;
  const fns = /* @__PURE__ */ new Set();
  let step = 0;
  let isRunning = false;
  let interval;
  function start() {
    step = 0;
    isRunning = true;
    interval = setInterval(() => {
      if (isRunning) {
        for (const fn of fns) {
          fn(step);
        }
        step = (step + 1) % steps;
      }
    }, ms);
  }
  function stop() {
    isRunning = false;
    clearInterval(interval);
  }
  return {
    add(fn) {
      fns.add(fn);
      if (!isRunning) {
        start();
      }
      fn(step);
      return () => {
        fns.delete(fn);
        if (!fns.size) {
          stop();
        }
      };
    }
  };
}

// src/adapter/middleware.ts
var import_node_stream = require("node:stream");

// src/adapter/polyfill.ts
var import_crypto = require("crypto");
var import_http = require("http");
var webStream = __toESM(require("stream/web"), 1);
var undici = __toESM(require("undici"), 1);
globalThis.crypto ?? (globalThis.crypto = import_crypto.webcrypto);
globalThis.fetch ?? (globalThis.fetch = undici.fetch);
globalThis.Response ?? (globalThis.Response = undici.Response);
globalThis.Request ?? (globalThis.Request = undici.Request);
globalThis.Headers ?? (globalThis.Headers = undici.Headers);
globalThis.ReadableStream ?? (globalThis.ReadableStream = webStream.ReadableStream);
globalThis.TransformStream ?? (globalThis.TransformStream = webStream.TransformStream);
globalThis.WritableStream ?? (globalThis.WritableStream = webStream.WritableStream);
globalThis.FormData ?? (globalThis.FormData = undici.FormData);
globalThis.File ?? (globalThis.File = undici.File);
var appendHeader = import_http.ServerResponse.prototype.appendHeader ? appendHeader_platform : appendHeader_fallback;
function appendHeader_platform(response, name, value) {
  response.appendHeader(name, value);
}
function appendHeader_fallback(response, name, value) {
  const existing = response.getHeader(name);
  if (existing === void 0) {
    response.setHeader(name, value);
  } else if (Array.isArray(existing)) {
    response.setHeader(name, existing.concat(value));
  } else {
    response.setHeader(name, [String(existing)].concat(value));
  }
}
var getSetCookie = Headers.prototype.getSetCookie ? getSetCookie_platform : getSetCookie_fallback;
function getSetCookie_platform(headers) {
  return headers.getSetCookie();
}
var inExpiresDateRgs = /Expires\s*=\s*(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s*$/i;
function getSetCookie_fallback(headers) {
  const value = headers.get("set-cookie");
  if (!value) return void 0;
  let sepIndex = value.indexOf(",") + 1;
  if (!sepIndex) return value;
  let index = 0;
  let setCookie = void 0;
  let setCookies = void 0;
  do {
    const valuePart = value.slice(index, sepIndex - 1);
    if (!inExpiresDateRgs.test(valuePart)) {
      if (setCookies) {
        setCookies.push(valuePart);
      } else if (setCookie) {
        setCookies = [setCookie, valuePart];
      } else {
        setCookie = valuePart;
      }
      index = sepIndex;
      while (value.charCodeAt(index) === 32) index++;
    }
    sepIndex = value.indexOf(",", sepIndex) + 1;
  } while (sepIndex);
  if (index) {
    const valuePart = value.slice(index);
    if (setCookies) {
      setCookies.push(valuePart);
      return setCookies;
    }
    return [setCookie, valuePart];
  }
  return value;
}

// src/adapter/middleware.ts
function getForwardedHeader(req, name) {
  const value = req.headers["x-forwarded-" + name];
  if (value) {
    if (typeof value === "string") {
      const index = value.indexOf(",");
      return index < 0 ? value : value.slice(0, index);
    }
    return value[0];
  }
}
function getOrigin(req, trustProxy) {
  const protocol = trustProxy && getForwardedHeader(req, "proto") || req.socket.encrypted && "https" || req.protocol || "http";
  let host = trustProxy && getForwardedHeader(req, "host") || req.headers.host;
  if (!host) {
    if (process.env.NODE_ENV !== "production") {
      host = "localhost";
      console.warn(
        `Could not automatically determine the origin host, using 'localhost'. Use the 'origin' option or the 'ORIGIN' environment variable to set the origin explicitly.`
      );
    } else {
      throw new Error(
        `Could not automatically determine the origin host. Use the 'origin' option or the 'ORIGIN' environment variable to set the origin explicitly.`
      );
    }
  }
  return `${protocol}://${host}`;
}
function copyResponseHeaders(response, headers) {
  for (const [key, value] of headers) {
    if (key !== "set-cookie") {
      response.setHeader(key, value);
    }
  }
  const setCookies = getSetCookie(headers);
  if (setCookies == null ? void 0 : setCookies.length) {
    appendHeader(response, "set-cookie", setCookies);
  }
}
function normalizeError(error) {
  if (error.cause && !error.message) {
    error.message = error.cause.message;
    error.stack || (error.stack = error.cause.stack);
  }
  return error;
}
function createMiddleware(fetch2, options) {
  const {
    origin = process.env.ORIGIN,
    trustProxy = process.env.TRUST_PROXY === "1",
    createPlatform = (platform) => platform
  } = options ?? (options = {});
  return async (req, res, next) => {
    var _a;
    const controller = new AbortController();
    const { signal } = controller;
    const url = new URL(req.url, origin || getOrigin(req, trustProxy));
    req.on("error", onErrorOrClose);
    req.socket.on("error", onErrorOrClose);
    res.on("error", onErrorOrClose);
    res.on("close", onErrorOrClose);
    signal.addEventListener("abort", onSignalAborted);
    function onErrorOrClose(err) {
      req.off("error", onErrorOrClose);
      req.socket.off("error", onErrorOrClose);
      res.off("error", onErrorOrClose);
      res.off("close", onErrorOrClose);
      if (err) {
        signal.removeEventListener("abort", onSignalAborted);
        controller.abort(err);
      }
    }
    function onSignalAborted() {
      const error = normalizeError(signal.reason);
      if (next) {
        next(error);
      } else {
        if (!res.destroyed && res.socket) {
          res.socket.destroySoon();
        }
        console.error(error);
      }
    }
    if (process.env.NODE_ENV !== "production" && globalThis.__marko_run_dev__ && ((_a = req.headers.accept) == null ? void 0 : _a.includes("text/html"))) {
      globalThis.__marko_run_dev__.onClient(res, (ws) => {
        if (signal.aborted) {
          sendError();
        } else {
          signal.addEventListener("abort", sendError);
        }
        function sendError() {
          const { message, stack = "" } = normalizeError(signal.reason);
          ws.send(
            JSON.stringify({
              type: "error",
              err: { message, stack }
            })
          );
        }
      });
    }
    let body;
    switch (req.method) {
      case "POST":
      case "PUT":
      case "PATCH":
        if (import_node_stream.Readable.isDisturbed(req)) {
          body = bodyConsumedErrorStream;
        } else {
          body = req;
        }
        break;
    }
    const request = new Request(url, {
      method: req.method,
      headers: req.headers,
      body,
      // @ts-expect-error: Node requires this for streams
      duplex: "half",
      signal
    });
    const platform = createPlatform({
      request: req,
      response: res
    });
    let response;
    try {
      response = await fetch2(request, platform);
    } catch (err) {
      normalizeError(err);
      if (next) {
        next(err);
      } else {
        console.error(err);
      }
      return;
    }
    if (!response) {
      if (next) {
        next();
      }
      return;
    }
    res.statusCode = response.status;
    copyResponseHeaders(res, response.headers);
    if (!response.body) {
      if (!response.headers.has("content-length")) {
        res.setHeader("content-length", "0");
      }
      res.end();
      return;
    } else if (res.destroyed) {
      controller.abort(new Error("Response stream destroyed"));
      return;
    }
    writeResponse(response.body.getReader(), res, controller);
  };
}
async function writeResponse(reader, res, controller) {
  try {
    while (!controller.signal.aborted) {
      const { done, value } = await reader.read();
      if (done) {
        res.end();
        return;
      }
      res.write(value);
      if (res.flush) {
        res.flush();
      }
    }
  } catch (err) {
    controller.abort(err);
  }
}
var bodyConsumedErrorStream = new ReadableStream({
  pull(controller) {
    controller.error(
      new Error(
        "The request body stream has been destroyed or consumed by something before Marko Run."
      )
    );
  }
});

// src/adapter/utils.ts
var import_kleur2 = __toESM(require("kleur"), 1);
var import_supports_color = __toESM(require("supports-color"), 1);
function stripAnsi(string) {
  return string.replace(
    /([\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><])/g,
    ""
  );
}
function cleanStack(stack) {
  return stack.split(/\n/).filter((l) => /^\s*at/.test(l)).join("\n");
}
function prepareError(err) {
  var _a;
  return {
    message: stripAnsi(err.message),
    stack: stripAnsi(cleanStack(err.stack || "")),
    id: err.id,
    frame: stripAnsi(err.frame || ""),
    plugin: err.plugin,
    pluginCode: (_a = err.pluginCode) == null ? void 0 : _a.toString(),
    loc: err.loc
  };
}
function logInfoBox(address, explorer) {
  const color = !!import_supports_color.default.stdout;
  let message = import_kleur2.default.bold("Marko Run");
  if (true) {
    message += ` v${"0.5.16"}`;
  }
  message += "\n\n";
  message += import_kleur2.default.dim("Server listening at");
  message += "\n";
  message += import_kleur2.default.cyan(import_kleur2.default.underline(address));
  if (explorer) {
    message += "\n\n";
    message += import_kleur2.default.dim("Explore your routes");
    message += "\n";
    message += import_kleur2.default.dim(import_kleur2.default.green(import_kleur2.default.underline(explorer)));
  }
  const lines = drawMarkoBox(message, { color, fill: color });
  console.log(lines.join("\n") + "\n");
}
function drawMarkoBox(message, options) {
  const textPaddingWidth = 3;
  const logoPaddingWidth = 2;
  const textPadding = " ".repeat(textPaddingWidth);
  const logoPadding = " ".repeat(logoPaddingWidth);
  const logo = drawMarkoLogo(options);
  const textLines = message.split(/\n/);
  const textWidths = textLines.map(
    (line) => line.replace(/\x1b\[\d+m/g, "").length
  );
  const textWidth = Math.max(...textWidths);
  const height = Math.max(textLines.length + 2, logo.lines.length);
  const width = textPaddingWidth * 2 + logoPaddingWidth + textWidth + logo.width;
  const hBorder = "\u2500".repeat(width);
  const vBorder = "\u2502";
  const lineDiff = logo.lines.length - textLines.length;
  const textStartLine = lineDiff > 0 ? Math.max(Math.floor(lineDiff / 2), 1) : 1;
  const textEndLine = height - (lineDiff > 0 ? Math.ceil(lineDiff / 2) : 1);
  const logoEndLine = logo.lines.length;
  const logoFill = " ".repeat(logo.width);
  const textFill = " ".repeat(textWidth);
  const lines = [`\u256D${hBorder}\u256E`];
  for (let i = 0; i < height; i++) {
    let line = vBorder;
    line += logoPadding;
    if (i < logoEndLine) {
      line += logo.lines[i];
    } else {
      line += logoFill;
    }
    line += textPadding;
    if (i >= textStartLine && i < textEndLine) {
      const index = i - textStartLine;
      line += textLines[index];
      line += " ".repeat(textWidth - textWidths[index]);
    } else {
      line += textFill;
    }
    line += textPadding;
    line += vBorder;
    lines.push(line);
  }
  lines.push(`\u2570${hBorder}\u256F`);
  return lines;
}
function drawMarkoLogo(options = {}) {
  const { fill = true, color = true } = options;
  const source = `
   TT____  YY____  R____
  C\u2571T\u2572   \u2572G\u2571Y\u2572   \u2572 R\u2572   \u2572
 C\u2571  T\u2572  G\u2571  Y\u2572   \u2572 R\u2572   \u2572
C\u2571   \u2571T\u2572G\u2571   \u2571Y\u2572   \u2572 R\u2572   \u2572
B\u2572   \u2572 GG\u203E\u203E\u203E\u203E O\u2571   \u2571 P\u2571   \u2571
 B\u2572   \u2572    OOO\u2571   \u2571 P\u2571   \u2571
  B\u2572   \u2572  OOO\u2571   \u2571 P\u2571   \u2571
   B\u203E\u203E\u203E\u203E  OOO\u203E\u203E\u203E\u203E  P\u203E\u203E\u203E\u203E
`;
  const resetEscape = "\x1B[0m";
  const colorEscapeCodes = Object.entries({
    B: "#06cfe5",
    C: "#05a5f0",
    T: "#19d89c",
    G: "#81dc09",
    Y: "#ffd900",
    O: "#ff9500",
    R: "#f3154d",
    P: "#ce176c"
  }).reduce(
    (acc, [key, hex]) => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      acc[key] = `\x1B[38;2;${r};${g};${b}m`;
      return acc;
    },
    {}
  );
  const lines = [];
  const lineWidths = [];
  let line = "";
  let lineWidth = 0;
  let width = 0;
  for (let i = 0; i < source.length; i++) {
    let char = source[i];
    if (char === "\n") {
      if (line) {
        if (color) {
          line += resetEscape;
        }
        width = Math.max(lineWidth, width);
        lines.push(line);
        lineWidths.push(lineWidth);
        line = "";
        lineWidth = 0;
      }
    } else if (/[A-Z]/.test(char)) {
      while (source[i + 1] === char) i++;
      if (color) {
        line += colorEscapeCodes[char];
      }
      if (fill) {
        let fillChar = "";
        for (; i < source.length; i++) {
          char = source[i + 1];
          if (fillChar && char !== " ") {
            break;
          } else if (!fillChar) {
            fillChar = char;
          }
          line += fillChar;
          lineWidth++;
        }
      }
    } else {
      line += char;
      lineWidth++;
    }
  }
  for (let i = 0; i < lines.length; i++) {
    const padding = width - lineWidths[i];
    if (padding > 0) {
      lines[i] += " ".repeat(width - lineWidths[i]);
    }
  }
  return { lines, width };
}

// src/adapter/dev-server.ts
async function createViteDevServer(config2) {
  const finalConfig = {
    ...config2,
    appType: "custom",
    server: { ...config2 == null ? void 0 : config2.server, middlewareMode: true }
  };
  const { cors } = finalConfig.server;
  if (cors === void 0) {
    finalConfig.server.cors = { preflightContinue: true };
  } else if (typeof cors === "object") {
    cors.preflightContinue ?? (cors.preflightContinue = true);
  }
  const devServer = await (0, import_vite.createServer)(finalConfig);
  getDevGlobal().addDevServer(devServer);
  devServer.middlewares.use(logger_default());
  return devServer;
}
async function createDevServer(config2) {
  const devServer = await createViteDevServer(config2);
  const routerMiddleware = createMiddleware(
    (request, platform) => globalThis.__marko_run__.fetch(request, platform)
  );
  devServer.middlewares.use(async (req, res, next) => {
    try {
      await devServer.ssrLoadModule("@marko/run/router");
    } catch (err) {
      return next(err);
    }
    routerMiddleware(req, res, next);
  }).use(createErrorMiddleware(devServer));
  return devServer;
}
var ClientIdCookieName = "marko-run-client-id";
function getClientId(req) {
  if (req.headers.cookie) {
    const cookie = req.headers.cookie.split(/;\s+/).find((c) => c.startsWith(ClientIdCookieName));
    if (cookie) {
      return cookie.slice(ClientIdCookieName.length + 1);
    }
  }
}
var devGlobal;
function getDevGlobal() {
  if (!devGlobal) {
    let handleConnection2 = function(ws, req) {
      if (callbacks == null ? void 0 : callbacks.length) {
        const id = getClientId(req);
        const now = Date.now();
        const nextCallbacks = [];
        for (const entry of callbacks) {
          if (entry.id === id) {
            entry.callback(ws);
          } else if (entry.expires > now) {
            nextCallbacks.push(entry);
          }
        }
        callbacks = nextCallbacks;
      }
    };
    var handleConnection = handleConnection2;
    const devServers = /* @__PURE__ */ new Set();
    let callbacks = [];
    globalThis.__marko_run_dev__ = devGlobal = {
      devServers,
      addDevServer(devServer) {
        const originalClose = devServer.close;
        devServer.close = () => {
          devServers.delete(devServer);
          return originalClose.call(devServer);
        };
        devServers.add(devServer);
        devServer.ws.on("connection", handleConnection2);
      },
      clear() {
        callbacks = [];
        for (const devServer of devServers) {
          devServer.ws.off("connection", handleConnection2);
          devServer.close();
        }
      },
      onClient(res, callback) {
        const expires = Date.now() + 1e3;
        const id = Math.floor(Math.random() * expires).toString(36);
        callbacks.push({
          id,
          expires,
          callback
        });
        res.setHeader(
          "set-cookie",
          `${ClientIdCookieName}=${id}; Path=/; Max-Age=100; HttpOnly`
        );
      }
    };
  }
  return devGlobal;
}
function createErrorMiddleware(devServer) {
  return function errorMiddleware(error, _req, res, _next) {
    if (!error.id) {
      devServer.config.logger.error(
        (0, import_vite.buildErrorMessage)(error, [
          `\x1B[31;1mRequest failed with error: ${error.message}\x1B[0m`
        ])
      );
    }
    res.statusCode = 500;
    res.end(`
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Error</title>
    <script type="module">
      const error = ${JSON.stringify(prepareError(error)).replace(
      /</g,
      "\\u003c"
    )}
      try {
        const { ErrorOverlay } = await import(${JSON.stringify(import_path.default.posix.join(devServer.config.base, "/@vite/client"))})
        document.body.appendChild(new ErrorOverlay(error))
      } catch {
        const h = (tag, text) => {
          const el = document.createElement(tag)
          el.textContent = text
          return el
        }
        document.body.appendChild(h('h1', 'Internal Server Error'))
        document.body.appendChild(h('h2', error.message))
        document.body.appendChild(h('pre', error.stack))
        document.body.appendChild(h('p', '(Error overlay failed to load)'))
      }
    </script>
  </head>
  <body>
  </body>
</html>
    `);
  };
}

// src/adapter/index.ts
var import_parse_node_args = __toESM(require("parse-node-args"), 1);

// src/vite/constants.ts
var markoRunFilePrefix = "__marko-run__";
var virtualFilePrefix = "virtual:marko-run";

// src/adapter/index.ts
var __dirname = import_path2.default.dirname((0, import_url2.fileURLToPath)(__importMetaURL));
var defaultEntry = import_path2.default.join(__dirname, "default-entry");
var loadDevWorker = import_path2.default.join(__dirname, "load-dev-worker.mjs");
function adapter() {
  return {
    name: "base-adapter",
    async getEntryFile() {
      return defaultEntry;
    },
    async startDev(entry, config2, options) {
      const { port = 3e3, envFile } = options;
      globalThis.__marko_run_vite_config__ = config2;
      const explorerPromise = startExplorer();
      if (entry && entry !== defaultEntry) {
        const { nodeArgs } = (0, import_parse_node_args.default)(options.args);
        let worker;
        async function start() {
          const nextWorker = await spawnServerWorker(
            loadDevWorker,
            nodeArgs,
            port,
            envFile
          );
          nextWorker.on("message", (messsage) => {
            if (messsage === "restart") {
              start();
            }
          }).send({ type: "start", entry, config: config2 });
          await waitForWorker(nextWorker, port);
          if (worker) {
            const prevWorker = worker;
            worker.once("disconnect", () => {
              clearTimeout(timeout);
            });
            worker.send({ type: "shutdown" });
            worker.disconnect();
            const timeout = setTimeout(() => {
              prevWorker.kill();
            }, 2e3);
          }
          worker = nextWorker;
        }
        const [explorer2] = await Promise.all([explorerPromise, start()]);
        return {
          port,
          async close() {
            await Promise.allSettled([worker.kill(), explorer2 == null ? void 0 : explorer2.close()]);
          }
        };
      }
      const devServer = await createDevServer(config2);
      envFile && await loadEnv(envFile);
      const inspect = getInspectOptions(options.args);
      if (inspect) {
        import_inspector2.default.open(inspect.port, inspect.host, inspect.wait);
      }
      const listenerPromise = new Promise((resolve) => {
        const listener2 = devServer.middlewares.listen(port, () => {
          resolve(listener2);
        });
      });
      const [explorer, listener] = await Promise.all([
        explorerPromise,
        listenerPromise
      ]);
      const address = listener.address();
      logInfoBox(
        `http://localhost:${address.port}`,
        explorer && `http://localhost:${explorer.port}`
      );
      return {
        port: address.port,
        async close() {
          await Promise.allSettled([
            devServer.close(),
            listener.close(),
            explorer == null ? void 0 : explorer.close()
          ]);
        }
      };
    },
    async startPreview(entry, options) {
      const { port = 3e3, envFile } = options;
      const { nodeArgs } = (0, import_parse_node_args.default)(options.args);
      const args = [...nodeArgs, entry];
      const [explorer, server] = await Promise.all([
        startExplorer(),
        spawnServer("node", args, port, envFile)
      ]);
      if (options.entry === defaultEntry) {
        logInfoBox(
          `http://localhost:${port}`,
          explorer && `http://localhost:${explorer.port}`
        );
      }
      return explorer ? {
        port: server.port,
        async close() {
          await Promise.allSettled([server.close(), explorer.close()]);
        }
      } : server;
    },
    async routesGenerated(routes, virtualFiles, meta) {
      if (process.env.MR_EXPLORER === "false") {
        return;
      }
      const promises = [];
      const cacheDir = import_path2.default.resolve(__dirname, "../../.cache/explorer");
      const codeDir = import_path2.default.join(cacheDir, "code");
      if (import_fs2.default.existsSync(codeDir)) {
        await import_fs2.default.promises.rm(codeDir, { recursive: true });
      }
      await import_fs2.default.promises.mkdir(codeDir, { recursive: true });
      const data = {
        meta,
        routes: {},
        files: {}
      };
      for (const [name, code] of virtualFiles) {
        let fileName = "";
        const index = name.indexOf(markoRunFilePrefix);
        if (index >= 0) {
          fileName = name.slice(index);
          data.files[fileName] = `${virtualFilePrefix}/${fileName}`;
        } else if (name.startsWith("@marko/run")) {
          fileName = name.slice(11);
          data.files[fileName] = name;
        }
        if (fileName) {
          promises.push(
            import_fs2.default.promises.writeFile(import_path2.default.join(codeDir, fileName), code, {})
          );
        }
      }
      for (const route of routes.list) {
        data.routes[route.index] = route;
      }
      for (const [id, route] of Object.entries(routes.special)) {
        data.routes["s" + id] = route;
      }
      promises.push(
        import_fs2.default.promises.writeFile(
          import_path2.default.join(cacheDir, "data.json"),
          JSON.stringify(data),
          {}
        )
      );
      await Promise.all(promises);
    }
  };
}
async function startExplorer() {
  if (process.env.MR_EXPLORER !== "false") {
    const port = await getAvailablePort(1234);
    return (0, import_run_explorer.start)(port);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createDevServer,
  createErrorMiddleware,
  createViteDevServer,
  getDevGlobal
});
