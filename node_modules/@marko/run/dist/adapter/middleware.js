// src/adapter/middleware.ts
import { Readable } from "node:stream";

// src/adapter/polyfill.ts
import { webcrypto } from "crypto";
import { ServerResponse } from "http";
import * as webStream from "stream/web";
import * as undici from "undici";
globalThis.crypto ?? (globalThis.crypto = webcrypto);
globalThis.fetch ?? (globalThis.fetch = undici.fetch);
globalThis.Response ?? (globalThis.Response = undici.Response);
globalThis.Request ?? (globalThis.Request = undici.Request);
globalThis.Headers ?? (globalThis.Headers = undici.Headers);
globalThis.ReadableStream ?? (globalThis.ReadableStream = webStream.ReadableStream);
globalThis.TransformStream ?? (globalThis.TransformStream = webStream.TransformStream);
globalThis.WritableStream ?? (globalThis.WritableStream = webStream.WritableStream);
globalThis.FormData ?? (globalThis.FormData = undici.FormData);
globalThis.File ?? (globalThis.File = undici.File);
var appendHeader = ServerResponse.prototype.appendHeader ? appendHeader_platform : appendHeader_fallback;
function appendHeader_platform(response, name, value) {
  response.appendHeader(name, value);
}
function appendHeader_fallback(response, name, value) {
  const existing = response.getHeader(name);
  if (existing === void 0) {
    response.setHeader(name, value);
  } else if (Array.isArray(existing)) {
    response.setHeader(name, existing.concat(value));
  } else {
    response.setHeader(name, [String(existing)].concat(value));
  }
}
var getSetCookie = Headers.prototype.getSetCookie ? getSetCookie_platform : getSetCookie_fallback;
function getSetCookie_platform(headers) {
  return headers.getSetCookie();
}
var inExpiresDateRgs = /Expires\s*=\s*(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s*$/i;
function getSetCookie_fallback(headers) {
  const value = headers.get("set-cookie");
  if (!value) return void 0;
  let sepIndex = value.indexOf(",") + 1;
  if (!sepIndex) return value;
  let index = 0;
  let setCookie = void 0;
  let setCookies = void 0;
  do {
    const valuePart = value.slice(index, sepIndex - 1);
    if (!inExpiresDateRgs.test(valuePart)) {
      if (setCookies) {
        setCookies.push(valuePart);
      } else if (setCookie) {
        setCookies = [setCookie, valuePart];
      } else {
        setCookie = valuePart;
      }
      index = sepIndex;
      while (value.charCodeAt(index) === 32) index++;
    }
    sepIndex = value.indexOf(",", sepIndex) + 1;
  } while (sepIndex);
  if (index) {
    const valuePart = value.slice(index);
    if (setCookies) {
      setCookies.push(valuePart);
      return setCookies;
    }
    return [setCookie, valuePart];
  }
  return value;
}

// src/adapter/middleware.ts
function getForwardedHeader(req, name) {
  const value = req.headers["x-forwarded-" + name];
  if (value) {
    if (typeof value === "string") {
      const index = value.indexOf(",");
      return index < 0 ? value : value.slice(0, index);
    }
    return value[0];
  }
}
function getOrigin(req, trustProxy) {
  const protocol = trustProxy && getForwardedHeader(req, "proto") || req.socket.encrypted && "https" || req.protocol || "http";
  let host = trustProxy && getForwardedHeader(req, "host") || req.headers.host;
  if (!host) {
    if (process.env.NODE_ENV !== "production") {
      host = "localhost";
      console.warn(
        `Could not automatically determine the origin host, using 'localhost'. Use the 'origin' option or the 'ORIGIN' environment variable to set the origin explicitly.`
      );
    } else {
      throw new Error(
        `Could not automatically determine the origin host. Use the 'origin' option or the 'ORIGIN' environment variable to set the origin explicitly.`
      );
    }
  }
  return `${protocol}://${host}`;
}
function copyResponseHeaders(response, headers) {
  for (const [key, value] of headers) {
    if (key !== "set-cookie") {
      response.setHeader(key, value);
    }
  }
  const setCookies = getSetCookie(headers);
  if (setCookies == null ? void 0 : setCookies.length) {
    appendHeader(response, "set-cookie", setCookies);
  }
}
function normalizeError(error) {
  if (error.cause && !error.message) {
    error.message = error.cause.message;
    error.stack || (error.stack = error.cause.stack);
  }
  return error;
}
function createMiddleware(fetch2, options) {
  const {
    origin = process.env.ORIGIN,
    trustProxy = process.env.TRUST_PROXY === "1",
    createPlatform = (platform) => platform
  } = options ?? (options = {});
  return async (req, res, next) => {
    var _a;
    const controller = new AbortController();
    const { signal } = controller;
    const url = new URL(req.url, origin || getOrigin(req, trustProxy));
    req.on("error", onErrorOrClose);
    req.socket.on("error", onErrorOrClose);
    res.on("error", onErrorOrClose);
    res.on("close", onErrorOrClose);
    signal.addEventListener("abort", onSignalAborted);
    function onErrorOrClose(err) {
      req.off("error", onErrorOrClose);
      req.socket.off("error", onErrorOrClose);
      res.off("error", onErrorOrClose);
      res.off("close", onErrorOrClose);
      if (err) {
        signal.removeEventListener("abort", onSignalAborted);
        controller.abort(err);
      }
    }
    function onSignalAborted() {
      const error = normalizeError(signal.reason);
      if (next) {
        next(error);
      } else {
        if (!res.destroyed && res.socket) {
          res.socket.destroySoon();
        }
        console.error(error);
      }
    }
    if (process.env.NODE_ENV !== "production" && globalThis.__marko_run_dev__ && ((_a = req.headers.accept) == null ? void 0 : _a.includes("text/html"))) {
      globalThis.__marko_run_dev__.onClient(res, (ws) => {
        if (signal.aborted) {
          sendError();
        } else {
          signal.addEventListener("abort", sendError);
        }
        function sendError() {
          const { message, stack = "" } = normalizeError(signal.reason);
          ws.send(
            JSON.stringify({
              type: "error",
              err: { message, stack }
            })
          );
        }
      });
    }
    let body;
    switch (req.method) {
      case "POST":
      case "PUT":
      case "PATCH":
        if (Readable.isDisturbed(req)) {
          body = bodyConsumedErrorStream;
        } else {
          body = req;
        }
        break;
    }
    const request = new Request(url, {
      method: req.method,
      headers: req.headers,
      body,
      // @ts-expect-error: Node requires this for streams
      duplex: "half",
      signal
    });
    const platform = createPlatform({
      request: req,
      response: res
    });
    let response;
    try {
      response = await fetch2(request, platform);
    } catch (err) {
      normalizeError(err);
      if (next) {
        next(err);
      } else {
        console.error(err);
      }
      return;
    }
    if (!response) {
      if (next) {
        next();
      }
      return;
    }
    res.statusCode = response.status;
    copyResponseHeaders(res, response.headers);
    if (!response.body) {
      if (!response.headers.has("content-length")) {
        res.setHeader("content-length", "0");
      }
      res.end();
      return;
    } else if (res.destroyed) {
      controller.abort(new Error("Response stream destroyed"));
      return;
    }
    writeResponse(response.body.getReader(), res, controller);
  };
}
async function writeResponse(reader, res, controller) {
  try {
    while (!controller.signal.aborted) {
      const { done, value } = await reader.read();
      if (done) {
        res.end();
        return;
      }
      res.write(value);
      if (res.flush) {
        res.flush();
      }
    }
  } catch (err) {
    controller.abort(err);
  }
}
var bodyConsumedErrorStream = new ReadableStream({
  pull(controller) {
    controller.error(
      new Error(
        "The request body stream has been destroyed or consumed by something before Marko Run."
      )
    );
  }
});
export {
  copyResponseHeaders,
  createMiddleware,
  getOrigin
};
