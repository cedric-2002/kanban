// src/runtime/internal.ts
var pageResponseInit = {
  status: 200,
  headers: { "content-type": "text/html;charset=UTF-8" }
};
function pageResponse(template, input) {
  return new Response(template.render(input), pageResponseInit);
}
var NotHandled = Symbol();
var NotMatched = Symbol();
globalThis.MarkoRun ?? (globalThis.MarkoRun = {
  NotHandled,
  NotMatched,
  route(handler) {
    return handler;
  }
});
var serializedGlobals = { params: true, url: true };
function createContext(route, request, platform, url = new URL(request.url)) {
  const context = route ? {
    request,
    url,
    platform,
    meta: route.meta,
    params: route.params,
    route: route.path,
    serializedGlobals
  } : {
    request,
    url,
    platform,
    meta: {},
    params: {},
    route: "",
    serializedGlobals
  };
  let input;
  return [
    context,
    (data) => {
      input ?? (input = {
        $global: context
      });
      return data ? Object.assign(input, data) : input;
    }
  ];
}
async function call(handler, next, context) {
  let response;
  if (process.env.NODE_ENV !== "production") {
    let nextCallCount = 0;
    let didThrow = false;
    try {
      response = await handler(context, () => {
        nextCallCount++;
        return next();
      });
    } catch (error) {
      didThrow = true;
      if (error instanceof Response) {
        return error;
      }
      throw error;
    } finally {
      if (!response && !didThrow && nextCallCount > 0) {
        console.warn(
          `Handler '${handler.name}' called its next function but no response was returned. This will cause the next function to be called again which is wasteful. Either return or throw the result of calling \`next\`, return or throw a new Response object or finally \`throw null\` to skip handling the request`
        );
      } else if (nextCallCount > 1) {
        console.warn(
          `Handler '${handler.name}' called its next function more than once. Make sure this is intentional because it is inefficient.`
        );
      }
    }
  } else {
    try {
      response = await handler(context, next);
    } catch (error) {
      if (error == null) {
        throw NotHandled;
      } else if (error instanceof Response) {
        return error;
      }
      throw error;
    }
  }
  if (response === null) {
    throw NotMatched;
  }
  return response || next();
}
function compose(handlers) {
  const len = handlers.length;
  if (!len) {
    return (_context, next) => next();
  } else if (len === 1) {
    return handlers[0];
  }
  return (context, next) => {
    let i = 0;
    return function nextHandler() {
      return i < len ? call(handlers[i++], nextHandler, context) : next();
    }();
  };
}
function normalize(obj) {
  if (typeof obj === "function") {
    return obj;
  } else if (Array.isArray(obj)) {
    return compose(obj);
  } else if (obj instanceof Promise) {
    const promise = obj.then((value) => {
      fn = Array.isArray(value) ? compose(value) : value;
    });
    let fn = async (context, next) => {
      await promise;
      return fn(context, next);
    };
    return (context, next) => fn(context, next);
  }
  return passthrough;
}
function stripResponseBodySync(response) {
  return response.body ? new Response(null, response) : response;
}
function stripResponseBody(response) {
  return "then" in response ? response.then(stripResponseBodySync) : stripResponseBodySync(response);
}
function passthrough() {
}
function noContent() {
  return new Response(null, {
    status: 204
  });
}
function notHandled() {
  throw null;
}
function notMatched() {
  return null;
}
export {
  NotHandled,
  NotMatched,
  call,
  compose,
  createContext,
  noContent,
  normalize,
  notHandled,
  notMatched,
  pageResponse,
  passthrough,
  stripResponseBody,
  stripResponseBodySync
};
