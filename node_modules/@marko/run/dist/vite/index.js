var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/vite/plugin.ts
import markoVitePlugin from "@marko/vite";
import browserslist from "browserslist";
import { createHash } from "crypto";
import createDebug from "debug";
import { resolveToEsbuildTarget } from "esbuild-plugin-browserslist";
import fs3 from "fs";
import { glob } from "glob";
import path4 from "path";
import { fileURLToPath } from "url";
import { buildErrorMessage, mergeConfig } from "vite";

// src/adapter/utils.ts
import kleur from "kleur";
import supporsColor from "supports-color";
function stripAnsi(string) {
  return string.replace(
    /([\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><])/g,
    ""
  );
}
function cleanStack(stack) {
  return stack.split(/\n/).filter((l) => /^\s*at/.test(l)).join("\n");
}
function prepareError(err) {
  var _a;
  return {
    message: stripAnsi(err.message),
    stack: stripAnsi(cleanStack(err.stack || "")),
    id: err.id,
    frame: stripAnsi(err.frame || ""),
    plugin: err.plugin,
    pluginCode: (_a = err.pluginCode) == null ? void 0 : _a.toString(),
    loc: err.loc
  };
}

// src/vite/codegen/index.ts
import path from "path";

// src/vite/constants.ts
var markoRunFilePrefix = "__marko-run__";
var virtualFilePrefix = "virtual:marko-run";
var httpVerbs = [
  "get",
  "head",
  "post",
  "put",
  "delete",
  "patch",
  "options"
];
var serverEntryQuery = "?marko-server-entry";
var RoutableFileTypes = {
  Page: "page",
  Layout: "layout",
  Handler: "handler",
  Middleware: "middleware",
  Meta: "meta",
  NotFound: "404",
  Error: "500"
};

// src/vite/utils/route.ts
var httpVerbOrder = httpVerbs.reduce(
  (order, verb, index) => {
    order[verb] = index;
    return order;
  },
  {}
);
function getVerbs(route, noAutoHead) {
  var _a;
  const verbs = new Set((_a = route.handler) == null ? void 0 : _a.verbs);
  if (route.page) {
    verbs.add("get");
  }
  if (!noAutoHead && verbs.has("get")) {
    verbs.add("head");
  }
  return [...verbs].sort((a, b) => httpVerbOrder[a] - httpVerbOrder[b]);
}
function hasVerb(route, verb) {
  var _a, _b;
  return verb === "get" && !!route.page || ((_b = (_a = route.handler) == null ? void 0 : _a.verbs) == null ? void 0 : _b.includes(verb)) || verb === "head" && hasVerb(route, "get");
}

// src/vite/codegen/writer.ts
function createWriter(sink, options) {
  let buffer = "";
  let indentLevel = 0;
  let indentString = "";
  let firstOpenIndex = 0;
  const branches = [];
  const openWriters = /* @__PURE__ */ new Map();
  function write(data) {
    if (!writer.__isActive) {
      throw new Error("Cannot write to branch that has been joined");
    }
    if (openWriters.size) {
      buffer += data;
    } else {
      sink(data);
    }
    return writer;
  }
  const writer = {
    __isActive: true,
    get indent() {
      return indentLevel;
    },
    set indent(value) {
      if (options == null ? void 0 : options.indentWith) {
        if (value < 0) {
          value = 0;
        }
        if (value !== indentLevel) {
          indentLevel = value;
          indentString = options.indentWith.repeat(indentLevel);
        }
      }
    },
    write(data, indent = false) {
      if (indent && indentString) {
        write(indentString);
      }
      return write(data);
    },
    writeLines(...lines) {
      for (const line of lines) {
        if (line) {
          writer.write(line, true);
        }
        writer.write("\n");
      }
      return writer;
    },
    writeBlockStart(data) {
      writer.writeLines(data).indent++;
      return writer;
    },
    writeBlockEnd(data = "}") {
      writer.indent--;
      writer.writeLines(data);
      return writer;
    },
    writeBlock(start, lines, end) {
      return writer.writeBlockStart(start).writeLines(...lines).writeBlockEnd(end);
    },
    branch(name) {
      const existing = openWriters.get(name);
      if (existing) {
        return existing;
      }
      const branch = {
        buffer,
        writer: createWriter(
          (data) => {
            branch.buffer += data;
          },
          {
            ...options,
            onJoin() {
              openWriters.delete(name);
              for (let i = firstOpenIndex; i < branches.length; i++) {
                const b = branches[i];
                if (!b) {
                  continue;
                } else if (b.writer.__isActive) {
                  break;
                }
                sink(b.buffer);
                branches[i] = null;
                firstOpenIndex++;
              }
              if (!openWriters.size) {
                sink(buffer);
                buffer = "";
              }
            }
          }
        )
      };
      branch.writer.indent = indentLevel;
      openWriters.set(name, branch.writer);
      branches.push(branch);
      buffer = "";
      return branch.writer;
    },
    join(recursive) {
      var _a;
      if (writer.__isActive) {
        if (openWriters.size) {
          if (recursive) {
            for (const branch of openWriters.values()) {
              branch.join(true);
            }
          } else {
            throw new Error(
              `Cannot join a Writer with un-joined branches - use the \`recursive\` argument to join all open branches`
            );
          }
        }
        buffer && sink(buffer);
        writer.__isActive = false;
        (_a = options == null ? void 0 : options.onJoin) == null ? void 0 : _a.call(options, writer);
      }
    }
  };
  return writer;
}
function createStringWriter(opts) {
  let code = "";
  const writer = createWriter(
    (data) => {
      code += data;
    },
    { indentWith: "	", ...opts }
  );
  return Object.assign(writer, {
    end() {
      writer.join(true);
      return code;
    }
  });
}

// src/vite/codegen/index.ts
function renderRouteTemplate(route, getRelativePath) {
  if (!route.page) {
    throw new Error(`Route ${route.key} has no page to render`);
  }
  return renderEntryTemplate(
    route.entryName,
    [...route.layouts, route.page].map(
      (file) => getRelativePath(file.importPath)
    ),
    route.key === RoutableFileTypes.Error ? ["error"] : []
  );
}
function renderEntryTemplate(name, files, pageInputs = []) {
  if (!name) {
    throw new Error(`Invalid argument - 'name' cannot be empty`);
  }
  if (!files.length) {
    throw new Error(`Invalid argument - 'files' cannot be empty`);
  }
  const writer = createStringWriter();
  writer.writeLines(`// ${name}.marko`);
  writer.branch("imports");
  writer.writeLines("");
  writeEntryTemplateTag(writer, files, pageInputs);
  return writer.end();
}
function writeEntryTemplateTag(writer, [file, ...rest], pageInputs, index = 1) {
  if (file) {
    const isLast = !rest.length;
    const tag = isLast ? "Page" : `Layout${index}`;
    writer.branch("imports").writeLines(`import ${tag} from '${file}';`);
    if (isLast) {
      const attributes = pageInputs.length ? " " + pageInputs.map((name) => `${name}=input.${name}`).join(" ") : "";
      writer.writeLines(`<${tag}${attributes}/>`);
    } else {
      writer.writeBlockStart(`<${tag}>`);
      writeEntryTemplateTag(writer, rest, pageInputs, index + 1);
      writer.writeBlockEnd(`</>`);
    }
  }
}
function renderRouteEntry(route, entriesDir) {
  var _a;
  const { key, index, handler, page, middleware, meta, entryName } = route;
  const verbs = getVerbs(route);
  if (!verbs) {
    throw new Error(
      `Route ${key} doesn't have a handler or page for any HTTP verbs`
    );
  }
  const writer = createStringWriter();
  writer.writeLines(`// ${virtualFilePrefix}/${entryName}.js`);
  const imports = writer.branch("imports");
  const runtimeImports = [];
  if (handler) {
    runtimeImports.push("normalize");
  }
  if (handler || middleware.length) {
    runtimeImports.push("call");
  }
  if (!page || verbs.some((verb) => verb !== "get" && verb !== "head")) {
    runtimeImports.push("noContent");
  }
  if (page) {
    runtimeImports.push("pageResponse");
  }
  if (verbs.includes("head")) {
    runtimeImports.push("stripResponseBody");
  }
  if (runtimeImports.length) {
    imports.writeLines(
      `import { ${runtimeImports.join(
        ", "
      )} } from '${virtualFilePrefix}/runtime/internal';`
    );
  }
  if (middleware.length) {
    const names = middleware.map((m) => `mware${m.id}`);
    imports.writeLines(
      `import { ${names.join(
        ", "
      )} } from '${virtualFilePrefix}/${markoRunFilePrefix}middleware.js';`
    );
  }
  if ((_a = handler == null ? void 0 : handler.verbs) == null ? void 0 : _a.length) {
    writer.writeLines("");
    const names = [];
    for (const verb of handler.verbs) {
      const importName = verb.toUpperCase();
      names.push(importName);
      writer.writeLines(`const ${verb}Handler = normalize(${importName});`);
    }
    imports.writeLines(
      `import { ${names.join(", ")} } from './${handler.importPath}';`
    );
  }
  if (page) {
    const pageNameIndex = page.name.indexOf("+page");
    const pageNamePrefix = pageNameIndex > 0 ? `${page.name.slice(0, pageNameIndex)}.` : "";
    const importPath = route.layouts.length ? `./${path.posix.join(entriesDir, page.relativePath, "..", pageNamePrefix + "route.marko")}` : `./${page.importPath}`;
    imports.writeLines(`import page from '${importPath}${serverEntryQuery}';`);
  }
  if (meta) {
    imports.writeLines(
      `export { default as meta${index} } from './${meta.importPath}';`
    );
  }
  for (const verb of verbs) {
    writeRouteEntryHandler(writer, route, verb);
  }
  return writer.end();
}
function writeRouteEntryHandler(writer, route, verb) {
  var _a, _b, _c, _d;
  const { key, index, page, handler, middleware } = route;
  const len = middleware.length;
  let nextName;
  let currentName;
  let hasBody = false;
  writer.writeLines("");
  if (page && (verb === "get" || verb === "head")) {
    writer.writeBlockStart(
      `export function ${verb}${index}(context, buildInput) {`
    );
  } else {
    writer.writeBlockStart(`export function ${verb}${index}(context) {`);
  }
  const continuations = writer.branch("cont");
  if (page && (verb === "get" || verb === "head")) {
    currentName = "__page";
    if ((_a = handler == null ? void 0 : handler.verbs) == null ? void 0 : _a.includes(verb)) {
      const name = `${verb}Handler`;
      continuations.writeLines(
        `const ${currentName} = () => pageResponse(page, buildInput());`
      );
      if (len) {
        nextName = currentName;
        currentName = `__${name}`;
        continuations.writeLines(
          `const ${currentName} = () => call(${name}, ${nextName}, context);`
        );
      } else {
        if (verb === "head") {
          writer.writeLines(
            `return stripResponseBody(call(${name}, ${currentName}, context));`
          );
        } else {
          writer.writeLines(`return call(${name}, ${currentName}, context);`);
        }
        hasBody = true;
      }
    } else if (verb === "head") {
      writer.writeLines(
        `return stripResponseBody(get${index}(context, buildInput));`
      );
      hasBody = true;
    } else if (len) {
      continuations.writeLines(
        `const ${currentName} = () => pageResponse(page, buildInput());`
      );
      nextName = currentName;
    } else {
      writer.writeLines(`return pageResponse(page, buildInput());`);
      hasBody = true;
    }
  } else if ((_b = handler == null ? void 0 : handler.verbs) == null ? void 0 : _b.includes(verb)) {
    const name = `${verb}Handler`;
    currentName = `__${name}`;
    nextName = "noContent";
    if (len) {
      continuations.writeLines(
        `const ${currentName} = () => call(${name}, ${nextName}, context);`
      );
    } else {
      if (verb === "head") {
        writer.writeLines(
          `return stripResponseBody(call(${name}, ${nextName}, context));`
        );
      } else {
        writer.writeLines(`return call(${name}, ${nextName}, context);`);
      }
      hasBody = true;
    }
  } else if (verb === "head" && ((_d = (_c = route.handler) == null ? void 0 : _c.verbs) == null ? void 0 : _d.includes("get"))) {
    writer.writeLines(`return stripResponseBody(get${index}(context));`);
    hasBody = true;
  } else {
    throw new Error(`Route ${key} has no handler for ${verb} requests`);
  }
  if (!hasBody) {
    let i = len;
    while (i--) {
      const { id } = middleware[i];
      const name = `mware${id}`;
      nextName = currentName;
      currentName = i ? `__${name}` : "";
      if (currentName) {
        continuations.writeLines(
          `const ${currentName} = () => call(${name}, ${nextName}, context);`
        );
      } else if (verb === "head") {
        continuations.writeLines(
          `return stripResponseBody(call(${name}, ${nextName}, context));`
        );
      } else {
        continuations.writeLines(`return call(${name}, ${nextName}, context);`);
      }
    }
  }
  continuations.join();
  writer.writeBlockEnd("}");
}
function renderRouter(routes, entriesDir, options = {
  trailingSlashes: "RedirectWithout"
}) {
  const writer = createStringWriter();
  writer.writeLines(`// @marko/run/router`);
  const imports = writer.branch("imports");
  imports.writeLines(
    `import { NotHandled, NotMatched, createContext } from '${virtualFilePrefix}/runtime/internal';`
  );
  for (const route of routes.list) {
    const verbs = getVerbs(route);
    const names = verbs.map((verb) => `${verb}${route.index}`);
    route.meta && names.push(`meta${route.index}`);
    imports.writeLines(
      `import { ${names.join(", ")} } from '${virtualFilePrefix}/${route.entryName}.js';`
    );
  }
  for (const route of Object.values(routes.special)) {
    const importPath = route.layouts.length ? `./${path.posix.join(entriesDir, route.page.relativePath, "..", `route.${route.key}.marko`)}` : `./${route.page.importPath}`;
    imports.writeLines(
      `import page${route.key} from '${importPath}${serverEntryQuery}';`
    );
  }
  writer.writeLines(
    `
globalThis.__marko_run__ = { match, fetch, invoke };
    `
  ).writeBlockStart(`export function match(method, pathname) {`).writeLines(
    `if (!pathname) {
    pathname = '/';
  } else if (pathname.charAt(0) !== '/') {
    pathname = '/' + pathname;
  }`
  ).writeBlockStart(`switch (method) {`);
  for (const verb of httpVerbs) {
    const filteredRoutes = routes.list.filter((route) => hasVerb(route, verb));
    if (filteredRoutes.length) {
      const trie = createRouteTrie(filteredRoutes);
      writer.writeLines(`case '${verb.toUpperCase()}':`);
      writer.writeBlockStart(`case '${verb.toLowerCase()}': {`);
      writeRouterVerb(writer, trie, verb);
      writer.writeBlockEnd("}");
    }
  }
  writer.writeBlockEnd("}").writeLines("return null;").writeBlockEnd("}");
  writer.writeLines("").writeBlockStart(
    "export async function invoke(route, request, platform, url) {"
  ).writeLines(
    "const [context, buildInput] = createContext(route, request, platform, url);"
  );
  const hasErrorPage = Boolean(routes.special[RoutableFileTypes.Error]);
  if (hasErrorPage) {
    writer.writeBlockStart("try {");
  }
  writer.writeBlockStart("if (route) {").writeBlockStart("try {").writeLines(
    "const response = await route.handler(context, buildInput);",
    "if (response) return response;"
  ).indent--;
  writer.writeBlockStart("} catch (error) {").writeLines(
    "if (error === NotHandled) return;",
    "if (error !== NotMatched) throw error;"
  ).writeBlockEnd("}").writeBlockEnd("}");
  if (routes.special[RoutableFileTypes.NotFound]) {
    imports.writeLines(
      `
const page404ResponseInit = {
  status: 404,
  headers: { "content-type": "text/html;charset=UTF-8" },
};`
    );
    writer.write(`    
    if (context.request.headers.get('Accept')?.includes('text/html')) {
      return new Response(page404.stream(buildInput()), page404ResponseInit);
    }
`);
  }
  writer.indent--;
  if (hasErrorPage) {
    imports.writeLines(`
const page500ResponseInit = {
  status: 500,
  headers: { "content-type": "text/html;charset=UTF-8" },
};`);
    writer.writeBlockStart(`} catch (error) {`).writeBlockStart(
      `if (context.request.headers.get('Accept')?.includes('text/html')) {`
    ).writeLines(
      `return new Response(page500.stream(buildInput({ error })), page500ResponseInit);`
    ).writeBlockEnd("}").writeLines("throw error;").writeBlockEnd("}");
  }
  writer.writeBlockEnd("}");
  renderFetch(writer, options);
  return writer.end();
}
function renderFetch(writer, options) {
  writer.write(`
export async function fetch(request, platform) {
  try {
    const url = new URL(request.url);
    let { pathname } = url;`);
  switch (options.trailingSlashes) {
    case "RedirectWithout":
      writer.write(`
    if (pathname !== '/' && pathname.endsWith('/')) {
      url.pathname = pathname.slice(0, -1);
      return Response.redirect(url);
    }`);
      break;
    case "RedirectWith":
      writer.write(`
    if (pathname !== '/' && !pathname.endsWith('/')) {
      url.pathname = pathname + '/';
      return Response.redirect(url);
    }`);
      break;
    case "RewriteWithout":
      writer.write(`
    if (pathname !== '/' && pathname.endsWith('/')) {
      url.pathname = pathname = pathname.slice(0, -1);
    }`);
      break;
    case "RewriteWith":
      writer.write(`
    if (pathname !== '/' && !pathname.endsWith('/')) {
      url.pathname = pathname = pathname + '/';
    }`);
      break;
  }
  writer.write(`   

    const route = match(request.method, pathname);
    return await invoke(route, request, platform, url);
  } catch (error) {
    if (import.meta.env.DEV) {
      throw error;
    }
    return new Response(null, {
      status: 500
    });
  }
}`);
}
function writeRouterVerb(writer, trie, verb, level = 0, offset = 1) {
  const { route, dynamic, catchAll } = trie;
  let closeCount = 0;
  if (level === 0) {
    writer.writeLines(`const len = pathname.length;`);
    if (route) {
      writer.writeLines(
        `if (len === 1) return ${renderMatch(verb, route, trie.path)}; // ${trie.path.path}`
      );
    } else if (trie.static || dynamic) {
      writer.writeBlockStart(`if (len > 1) {`);
      closeCount++;
    }
  }
  if (trie.static || dynamic) {
    const next = level + 1;
    const index = `i${next}`;
    let terminal;
    let children;
    writer.writeLines(`const ${index} = pathname.indexOf('/', ${offset}) + 1;`);
    if (trie.static) {
      for (const child of trie.static.values()) {
        if (child.route) {
          (terminal ?? (terminal = [])).push(child);
        }
        if (child.static || child.dynamic || child.catchAll) {
          (children ?? (children = [])).push(child);
        }
      }
    }
    if (terminal || (dynamic == null ? void 0 : dynamic.route)) {
      closeCount++;
      writer.writeBlockStart(`if (!${index} || ${index} === len) {`);
      let value = `pathname.slice(${offset}, ${index} ? -1 : len)`;
      if (dynamic == null ? void 0 : dynamic.route) {
        const segment = `s${next}`;
        writer.writeLines(`const ${segment} = decodeURIComponent(${value});`);
        value = segment;
      } else if (terminal == null ? void 0 : terminal.some(
        (terminal2) => decodeURIComponent(terminal2.key) !== terminal2.key
      )) {
        value = `decodeURIComponent(${value})`;
      }
      if (terminal) {
        const useSwitch = terminal.length > 1;
        if (useSwitch) {
          writer.writeBlockStart(`switch (${value}) {`);
        }
        for (const { key, path: path5, route: route2 } of terminal) {
          const decodedKey = decodeURIComponent(key);
          if (useSwitch) {
            writer.write(`case '${decodedKey}': `, true);
          } else {
            writer.write(`if (${value} === '${decodedKey}') `, true);
          }
          writer.write(
            `return ${renderMatch(verb, route2, path5)}; // ${path5.path}
`
          );
        }
        if (useSwitch) {
          writer.writeBlockEnd("}");
        }
      }
      if (dynamic == null ? void 0 : dynamic.route) {
        writer.writeLines(
          `if (${value}) return ${renderMatch(
            verb,
            dynamic.route,
            dynamic.path
          )}; // ${dynamic.path.path}`
        );
      }
    }
    if (children || (dynamic == null ? void 0 : dynamic.static) || (dynamic == null ? void 0 : dynamic.dynamic) || (dynamic == null ? void 0 : dynamic.catchAll)) {
      if (terminal || (dynamic == null ? void 0 : dynamic.route)) {
        writer.writeBlockEnd("} else {").indent++;
      } else {
        writer.writeBlockStart(`if (${index} && ${index} !== len) {`);
        closeCount++;
      }
      let value = `pathname.slice(${offset}, ${index} - 1)`;
      if ((dynamic == null ? void 0 : dynamic.static) || (dynamic == null ? void 0 : dynamic.dynamic) || (dynamic == null ? void 0 : dynamic.catchAll)) {
        const segment = `s${next}`;
        writer.writeLines(`const ${segment} = decodeURIComponent(${value});`);
        value = segment;
      } else if (children == null ? void 0 : children.some((child) => decodeURIComponent(child.key) !== child.key)) {
        value = `decodeURIComponent(${value})`;
      }
      if (children) {
        const useSwitch = children.length > 1;
        if (useSwitch) {
          writer.writeBlockStart(`switch (${value}) {`);
        }
        for (const child of children) {
          const decodedKey = decodeURIComponent(child.key);
          if (useSwitch) {
            writer.writeBlockStart(`case '${decodedKey}': {`);
          } else {
            writer.writeBlockStart(`if (${value} === '${decodedKey}') {`);
          }
          const nextOffset = typeof offset === "string" ? index : offset + child.key.length + 1;
          writeRouterVerb(writer, child, verb, next, nextOffset);
          if (useSwitch) {
            writer.writeBlockEnd("} break;");
          } else {
            writer.writeBlockEnd("}");
          }
        }
        if (useSwitch) {
          writer.writeBlockEnd("}");
        }
      }
      if ((dynamic == null ? void 0 : dynamic.static) || (dynamic == null ? void 0 : dynamic.dynamic) || (dynamic == null ? void 0 : dynamic.catchAll)) {
        writer.writeBlockStart(`if (${value}) {`);
        writeRouterVerb(writer, dynamic, verb, next, index);
        writer.writeBlockEnd(`}`);
      }
    }
  }
  while (closeCount--) {
    writer.writeBlockEnd("}");
  }
  if (catchAll) {
    writer.writeLines(
      `return ${renderMatch(
        verb,
        catchAll.route,
        catchAll.path,
        String(offset)
      )}; // ${catchAll.path.path}`
    );
  } else if (level === 0) {
    writer.writeLines("return null;");
  }
}
function wrapPropertyName(name) {
  name = decodeURIComponent(name);
  return /^[^A-Za-z_$]|[^A-Za-z0-9$_]/.test(name) ? `'${name}'` : name;
}
function renderParams(params, pathIndex) {
  let result = "";
  let catchAll = "";
  let sep = "{";
  for (const [name, index] of Object.entries(params)) {
    if (typeof index === "number") {
      result += `${sep} ${wrapPropertyName(name)}: s${index + 1}`;
      sep = ",";
    } else if (pathIndex) {
      catchAll = name;
    }
  }
  if (catchAll) {
    result += `${sep} ${wrapPropertyName(
      catchAll
    )}: pathname.slice(${pathIndex})`;
  }
  return result ? result + " }" : "{}";
}
function renderMatch(verb, route, path5, pathIndex) {
  const handler = `${verb}${route.index}`;
  const params = path5.params ? renderParams(path5.params, pathIndex) : "{}";
  const meta = route.meta ? `meta${route.index}` : "{}";
  const pathPattern = pathToURLPatternString(path5.path);
  return `{ handler: ${handler}, params: ${params}, meta: ${meta}, path: '${pathPattern}' }`;
}
function renderMiddleware(middleware) {
  const writer = createStringWriter();
  writer.writeLines(
    `// ${virtualFilePrefix}/${markoRunFilePrefix}middleware.js`
  );
  const imports = writer.branch("imports");
  imports.writeLines(
    `import { normalize } from '${virtualFilePrefix}/runtime/internal';`
  );
  writer.writeLines("");
  for (const { id, importPath } of middleware) {
    const importName = `middleware${id}`;
    imports.writeLines(`import ${importName} from './${importPath}';`);
    writer.writeLines(`export const mware${id} = normalize(${importName});`);
  }
  imports.join();
  return writer.end();
}
function stripTsExtension(path5) {
  const index = path5.lastIndexOf(".");
  if (index !== -1) {
    const ext = path5.slice(index + 1);
    if (ext.toLowerCase() === "ts") {
      return path5.slice(0, index);
    }
  }
  return path5;
}
async function renderRouteTypeInfo(routes, pathPrefix = ".", adapter) {
  var _a, _b;
  const writer = createStringWriter();
  writer.writeLines(
    `/*
  WARNING: This file is automatically generated and any changes made to it will be overwritten without warning.
  Do NOT manually edit this file or your changes will be lost.
*/
`,
    `import { NotHandled, NotMatched, GetPaths, PostPaths, GetablePath, GetableHref, PostablePath, PostableHref, Platform } from "@marko/run/namespace";`,
    `import type * as Run from "@marko/run";`
  );
  const headWriter = writer.branch("head");
  writer.writeLines("\n").writeBlockStart(`declare module "@marko/run" {`);
  if (adapter && adapter.typeInfo) {
    const platformType = await adapter.typeInfo(
      (data) => headWriter.write(data)
    );
    if (platformType) {
      writer.writeLines(`interface Platform extends ${platformType} {}
`);
    }
  }
  headWriter.join();
  writer.writeBlockStart(`interface AppData extends Run.DefineApp<{`).writeBlockStart("routes: {");
  const routesWriter = writer.branch("routes");
  writer.writeBlockEnd("}").writeBlockEnd(`}> {}`).writeBlockEnd(`}`);
  const routeTypes = /* @__PURE__ */ new Map();
  for (const route of routes.list) {
    let routeType = "";
    for (const path5 of route.paths) {
      const pathType = `"${pathToURLPatternString(path5.path)}"`;
      routeType += routeType ? " | " + pathType : pathType;
      routesWriter.writeLines(`${pathType}: Routes["${route.key}"];`);
    }
    for (const file of [route.handler, route.page]) {
      if (file) {
        const existing = routeTypes.get(file);
        if (!existing) {
          routeTypes.set(file, [routeType]);
        } else {
          existing.push(routeType);
        }
      }
    }
    for (const files of [route.middleware, route.layouts]) {
      if (files) {
        for (const file of files) {
          const existing = routeTypes.get(file);
          if (!existing) {
            routeTypes.set(file, [routeType]);
          } else {
            existing.push(routeType);
          }
        }
      }
    }
  }
  for (const special of Object.values(routes.special)) {
    routeTypes.set(special.page, []);
  }
  routesWriter.join();
  const handlerWriter = writer.branch("handler");
  const middlewareWriter = writer.branch("middleware");
  const pageWriter = writer.branch("page");
  const layoutWriter = writer.branch("layout");
  for (const [file, types] of routeTypes) {
    const path5 = `${pathPrefix}/${file.relativePath}`;
    const routeType = `Run.Routes[${types.join(" | ")}]`;
    switch (file.type) {
      case RoutableFileTypes.Handler:
        writeModuleDeclaration(handlerWriter, path5, routeType);
        break;
      case RoutableFileTypes.Middleware:
        writeModuleDeclaration(middlewareWriter, path5, routeType);
        break;
      case RoutableFileTypes.Page:
        writeModuleDeclaration(pageWriter, path5, routeType);
        break;
      case RoutableFileTypes.Layout:
        writeModuleDeclaration(
          layoutWriter,
          path5,
          routeType,
          `
  export interface Input {
    renderBody: Marko.Body;
  }`
        );
        break;
      case RoutableFileTypes.Error:
        writeModuleDeclaration(
          writer,
          path5,
          "globalThis.MarkoRun.Route",
          `
  export interface Input {
    error: unknown;
  }`
        );
        break;
      case RoutableFileTypes.NotFound:
        writeModuleDeclaration(writer, path5, "Run.Route");
        break;
    }
  }
  handlerWriter.join();
  middlewareWriter.join();
  pageWriter.join();
  layoutWriter.join();
  writer.writeBlockStart(`
type Routes = {`);
  for (const route of routes.list) {
    const { meta, handler, page } = route;
    if (page || handler) {
      const verbs = [];
      if (page || ((_a = handler == null ? void 0 : handler.verbs) == null ? void 0 : _a.includes("get"))) {
        verbs.push(`"get"`);
      }
      if ((_b = handler == null ? void 0 : handler.verbs) == null ? void 0 : _b.includes("post")) {
        verbs.push(`"post"`);
      }
      let routeType = `{ verb: ${verbs.join(" | ")};`;
      if (meta) {
        const metaPath = stripTsExtension(`${pathPrefix}/${meta.relativePath}`);
        let metaType = `typeof import("${metaPath}")`;
        if (/\.(ts|js|mjs)$/.test(meta.name)) {
          metaType += `["default"]`;
        }
        routeType += ` meta: ${metaType};`;
      }
      writer.writeLines(`"${route.key}": ${routeType} };`);
    }
  }
  writer.writeBlockEnd("}");
  return writer.end();
}
function writeModuleDeclaration(writer, path5, routeType, moduleTypes) {
  writer.writeLines("").write(`declare module "${stripTsExtension(path5)}" {`);
  if (moduleTypes) {
    writer.write(moduleTypes);
  }
  if (routeType) {
    const isMarko = path5.endsWith(".marko");
    writer.write(`
  namespace MarkoRun {
    export { NotHandled, NotMatched, GetPaths, PostPaths, GetablePath, GetableHref, PostablePath, PostableHref, Platform };
    export type Route = ${routeType};
    export type Context = Run.MultiRouteContext<Route>${isMarko ? " & Marko.Global" : ""};
    export type Handler = Run.HandlerLike<Route>;
    /** @deprecated use \`((context, next) => { ... }) satisfies MarkoRun.Handler\` instead */
    export const route: Run.HandlerTypeFn<Route>;
  }`);
  }
  writer.writeLines(`
}`);
}
function pathToURLPatternString(path5) {
  return path5.replace(/\/\$(\$?)([^/]*)/g, (_, catchAll, name) => {
    name = decodeURIComponent(name);
    return catchAll ? `/:${name || "rest"}*` : `/:${name}`;
  });
}
function createRouteTrie(routes) {
  const root = {
    key: ""
  };
  function insert(path5, route) {
    let node = root;
    for (const segment of path5.segments) {
      if (segment === "$$") {
        node.catchAll ?? (node.catchAll = { route, path: path5 });
        return;
      } else if (segment === "$") {
        node = node.dynamic ?? (node.dynamic = {
          key: ""
        });
      } else {
        node.static ?? (node.static = /* @__PURE__ */ new Map());
        let next = node.static.get(segment);
        if (!next) {
          next = {
            key: segment
          };
          node.static.set(segment, next);
        }
        node = next;
      }
    }
    node.path ?? (node.path = path5);
    node.route ?? (node.route = route);
  }
  for (const route of routes) {
    for (const path5 of route.paths) {
      insert(path5, route);
    }
  }
  return root;
}

// src/vite/routes/parse.ts
function parseFlatRoute(pattern) {
  if (!pattern) throw new Error("Empty pattern");
  const len = pattern.length;
  let i = 0;
  return parse2([
    {
      id: "/",
      segments: [],
      source: pattern
    }
  ]);
  function parse2(basePaths, group) {
    const pathMap = /* @__PURE__ */ new Map();
    const delimiters = group ? ").," : ".,";
    let charCode;
    let segmentStart = i;
    let type;
    let current;
    do {
      charCode = pattern.charCodeAt(i);
      if (charCode === 41 && group) {
        break;
      } else if (charCode === 44) {
        if (!current) {
          segmentEnd(
            basePaths.map((path5) => ({
              ...path5,
              segments: path5.segments.slice()
            })),
            "",
            "_",
            pathMap
          );
        } else {
          segmentEnd(current, pattern.slice(segmentStart, i), type, pathMap);
        }
        current = void 0;
        type = void 0;
        segmentStart = ++i;
      } else if (charCode === 46) {
        if (current) {
          segmentEnd(current, pattern.slice(segmentStart, i), type);
        }
        type = void 0;
        segmentStart = ++i;
      } else if (charCode === 40) {
        const groupPaths = parse2(current || basePaths, ++i);
        if (groupPaths.length) {
          current = groupPaths;
        }
        segmentStart = ++i;
      } else {
        if (charCode === 95) {
          type = "_";
        } else if (charCode === 36) {
          type = pattern.charCodeAt(i + 1) === 36 ? "$$" : "$";
        }
        current ?? (current = basePaths.map((path5) => ({
          ...path5,
          segments: path5.segments.slice()
        })));
        i = len;
        for (const char of delimiters) {
          const index = pattern.indexOf(char, segmentStart);
          if (index >= 0 && index < i) {
            i = index;
          }
        }
      }
    } while (i < len);
    if (group && charCode !== 41) {
      throw new Error(
        `Invalid route pattern: group was not closed '${pattern.slice(
          group
        )}' in '${pattern}'`
      );
    }
    if (!current) {
      segmentEnd(
        basePaths.map((path5) => ({
          ...path5,
          segments: path5.segments.slice()
        })),
        "",
        "_",
        pathMap
      );
    } else {
      segmentEnd(current, pattern.slice(segmentStart, i), type, pathMap);
    }
    return [...pathMap.values()];
  }
  function segmentEnd(paths, raw, type, map) {
    let segment;
    if (raw) {
      segment = {
        raw,
        name: raw,
        type
      };
      if (type === "$" || type === "$$") {
        segment.name = type;
        segment.param = raw.slice(type.length);
      }
    }
    for (const path5 of paths) {
      if (segment) {
        if (path5.isCatchall) {
          throw new Error(
            `Invalid route pattern: nested segments are not allowed after a catch-all parameter. Found '.' following '${pattern.slice(
              0,
              i
            )}' in '${pattern}'.`
          );
        }
        path5.segments.push(segment);
        path5.id += path5.id === "/" ? segment.name : `/${segment.name}`;
        if (type === "$$") {
          path5.isCatchall = true;
        }
      }
      if (map) {
        if (map.has(path5.id)) {
          const existing = map.get(path5.id);
          const existingExpansion = existing.segments.map((s) => s.raw).join(".");
          const currentExpansion = path5.segments.map((s) => s.raw).join(".");
          throw new Error(
            `Invalid route pattern: route '${path5.id}' is ambiguous. Expansion '${currentExpansion}' collides with '${existingExpansion}' in '${pattern}'.`
          );
        }
        map.set(path5.id, path5);
      }
    }
  }
}

// src/vite/routes/vdir.ts
var _dirs, _pathlessDirs;
var _VDir = class _VDir {
  constructor(parent, segment, source) {
    __privateAdd(this, _dirs);
    __privateAdd(this, _pathlessDirs);
    __publicField(this, "parent");
    __publicField(this, "source");
    __publicField(this, "path");
    __publicField(this, "fullPath");
    __publicField(this, "segment");
    __publicField(this, "files");
    if (!parent || !segment) {
      this.parent = null;
      this.source = null;
      this.path = "/";
      this.fullPath = "/";
      this.segment = {
        raw: "",
        name: ""
      };
    } else {
      this.parent = parent;
      this.source = source;
      this.path = parent.path + (parent.path === "/" ? segment.name : `/${segment.name}`);
      this.fullPath = parent.fullPath + (parent.fullPath === "/" ? segment.name : `/${segment.name}`);
      if (segment.param) {
        this.fullPath += segment.param;
      }
      this.segment = segment;
    }
  }
  get pathInfo() {
    const value = {
      id: "/",
      path: "/",
      segments: []
    };
    let sep = "";
    for (const { segment } of this) {
      const { type, name, param } = segment;
      if (name && type !== "_") {
        value.id += sep + (type || name);
        value.path += sep + name;
        value.isEnd = type === "$$";
        if (param) {
          value.path += param;
          const index = type === "$$" ? null : value.segments.length;
          if (!value.params) {
            value.params = { [param]: index };
          } else if (!(param in value.params)) {
            value.params[param] = index;
          }
        }
        value.segments.push(name);
        sep = "/";
      }
    }
    Object.defineProperty(this, "pathInfo", {
      value,
      enumerable: true
    });
    return value;
  }
  addDir(path5, segment) {
    const map = segment.type === "_" ? __privateGet(this, _pathlessDirs) ?? __privateSet(this, _pathlessDirs, /* @__PURE__ */ new Map()) : __privateGet(this, _dirs) ?? __privateSet(this, _dirs, /* @__PURE__ */ new Map());
    if (!map.has(segment.name)) {
      const dir = new _VDir(this, segment, path5);
      map.set(segment.name, dir);
      return dir;
    }
    return map.get(segment.name);
  }
  addFile(file) {
    if (!this.files) {
      this.files = /* @__PURE__ */ new Map();
      this.files.set(file.type, file);
    } else if (!this.files.has(file.type)) {
      this.files.set(file.type, file);
    } else {
      const existing = this.files.get(file.type);
      if (existing !== file) {
        throw new Error(
          `Duplicate file type '${file.type}' added at path '${this.path}'. File '${file.importPath}' collides with '${existing.importPath}'.`
        );
      } else if (file.type === RoutableFileTypes.Page || file.type === RoutableFileTypes.Handler) {
        throw new Error(
          `Ambiguous path definition: route '${this.path}' is defined multiple times by ${file.importPath}`
        );
      }
      throw new Error(
        `Ambiguous path definition: file '${this.path}' is included multiple times by ${file.importPath}`
      );
    }
  }
  *dirs() {
    if (__privateGet(this, _pathlessDirs)) {
      yield* __privateGet(this, _pathlessDirs).values();
    }
    if (__privateGet(this, _dirs)) {
      yield* __privateGet(this, _dirs).values();
    }
  }
  *[Symbol.iterator]() {
    if (this.parent) {
      yield* this.parent;
    }
    yield this;
  }
  static addPaths(roots, paths) {
    const dirs = [];
    const unique = /* @__PURE__ */ new Set();
    for (const root of roots) {
      for (const path5 of paths) {
        let dir = root;
        for (const segment of path5.segments) {
          dir = dir.addDir(path5, segment);
        }
        if (unique.has(dir.path)) {
          const sources = /* @__PURE__ */ new Set();
          let sourcePath = "";
          for (const { source } of dir) {
            if (source && !sources.has(source.source)) {
              sources.add(source.source);
              sourcePath += source.source + "/";
            }
          }
          throw new Error(
            `Ambiguous directory structure: '${sourcePath}${path5.source}' defines '${dir.path}' multiple times.`
          );
        } else {
          unique.add(dir.path);
          dirs.push(dir);
        }
      }
    }
    return dirs;
  }
};
_dirs = new WeakMap();
_pathlessDirs = new WeakMap();
var VDir = _VDir;

// src/vite/routes/builder.ts
var markoFiles = `(${RoutableFileTypes.Layout}|${RoutableFileTypes.Page}|${RoutableFileTypes.NotFound}|${RoutableFileTypes.Error})\\.(?:.*\\.)?(marko)`;
var nonMarkoFiles = `(${RoutableFileTypes.Middleware}|${RoutableFileTypes.Handler}|${RoutableFileTypes.Meta})\\.(?:.*\\.)?(.+)`;
var routeableFileRegex = new RegExp(
  `[+](?:${markoFiles}|${nonMarkoFiles})$`,
  "i"
);
function matchRoutableFile(filename) {
  const match = filename.match(routeableFileRegex);
  return match && (match[1] || match[3]).toLowerCase();
}
function isSpecialType(type) {
  return type === RoutableFileTypes.NotFound || type === RoutableFileTypes.Error;
}
async function buildRoutes(sources) {
  const uniqueRoutes = /* @__PURE__ */ new Map();
  const routes = [];
  const special = {};
  const middlewares = /* @__PURE__ */ new Set();
  const unusedFiles = /* @__PURE__ */ new Set();
  const currentLayouts = /* @__PURE__ */ new Set();
  const currentMiddleware = /* @__PURE__ */ new Set();
  const root = new VDir();
  const dirStack = [];
  let basePath;
  let importPrefix;
  let activeDirs;
  let isBaseDir;
  let nextFileId = 1;
  let nextRouteIndex = 1;
  const walkOptions = {
    onEnter({ name }) {
      const prevDirStackLength = dirStack.length;
      if (isBaseDir) {
        isBaseDir = false;
        if (!basePath) {
          return;
        }
        name = basePath;
      } else {
        dirStack.push(name);
      }
      const previousDirs = activeDirs;
      const paths = parseFlatRoute(name);
      activeDirs = VDir.addPaths(previousDirs, paths);
      return () => {
        activeDirs = previousDirs;
        dirStack.length = prevDirStackLength;
      };
    },
    onFile({ name, path: path5 }) {
      const match = name.match(routeableFileRegex);
      if (!match) {
        return;
      }
      const type = (match[1] || match[3]).toLowerCase();
      if (dirStack.length && isSpecialType(type)) {
        console.warn(
          `Special pages '${RoutableFileTypes.NotFound}' and '${RoutableFileTypes.Error}' are only considered in the root directory - ignoring ${path5}`
        );
        return;
      }
      let dirs = activeDirs;
      if (match.index) {
        const paths = parseFlatRoute(name.slice(0, match.index));
        dirs = VDir.addPaths(activeDirs, paths);
      }
      const dirPath = dirStack.join("/");
      const relativePath = dirPath ? `${dirPath}/${name}` : name;
      const file = {
        id: String(nextFileId++),
        name,
        type,
        filePath: path5,
        relativePath,
        importPath: `${importPrefix}/${relativePath}`,
        verbs: type === RoutableFileTypes.Page ? ["get", "head"] : void 0
      };
      for (const dir of dirs) {
        dir.addFile(file);
      }
    }
  };
  if (!Array.isArray(sources)) {
    sources = [sources];
  }
  for (const source of sources) {
    importPrefix = source.importPrefix ? source.importPrefix.replace(/^\/+|\/+$/g, "") : "";
    basePath = source.basePath || "";
    activeDirs = [root];
    isBaseDir = true;
    await source.walker(walkOptions);
  }
  traverse(root);
  return {
    list: routes,
    middleware: [...middlewares],
    special
  };
  function traverse(dir) {
    let middleware;
    let layout;
    if (dir.files) {
      middleware = dir.files.get(RoutableFileTypes.Middleware);
      layout = dir.files.get(RoutableFileTypes.Layout);
      const handler = dir.files.get(RoutableFileTypes.Handler);
      const page = dir.files.get(RoutableFileTypes.Page);
      let hasSpecial = false;
      if (middleware) {
        if (currentMiddleware.has(middleware)) {
          middleware = void 0;
        } else {
          currentMiddleware.add(middleware);
          unusedFiles.add(middleware);
        }
      }
      if (layout) {
        if (currentLayouts.has(layout)) {
          layout = void 0;
        } else {
          currentLayouts.add(layout);
          unusedFiles.add(layout);
        }
      }
      if (page || handler) {
        const path5 = dir.pathInfo;
        if (uniqueRoutes.has(path5.id)) {
          const existing = uniqueRoutes.get(path5.id);
          const route = routes[existing.index];
          const existingFiles = [route.handler, route.page].filter(Boolean).map((f) => f.filePath);
          const currentFiles = [handler, page].filter(Boolean).map((f) => f.filePath);
          throw new Error(`Duplicate routes for path '${path5.path}' were defined. A route established by:
      ${existingFiles.join(" and ")} via '${existing.dir.path}'
        collides with
      ${currentFiles.join(" and ")} via '${dir.path}'
      `);
        }
        uniqueRoutes.set(path5.id, { dir, index: routes.length });
        routes.push({
          index: nextRouteIndex++,
          key: dir.fullPath,
          paths: [path5],
          middleware: [...currentMiddleware],
          layouts: page ? [...currentLayouts] : [],
          meta: dir.files.get(RoutableFileTypes.Meta),
          page,
          handler,
          entryName: `${markoRunFilePrefix}route` + (dir.path !== "/" ? dir.fullPath.replace(/\//g, ".").replace(/(%[A-Fa-f0-9]{2})+/g, "_") : "")
        });
      }
      if (dir === root) {
        for (const [type, file] of dir.files) {
          if (isSpecialType(type)) {
            hasSpecial = true;
            special[type] = {
              index: 0,
              key: type,
              paths: [],
              middleware: [],
              layouts: [...currentLayouts],
              page: file,
              entryName: `${markoRunFilePrefix}special.${type}`
            };
          }
        }
      }
      if (handler || page) {
        for (const middleware2 of currentMiddleware) {
          middlewares.add(middleware2);
          unusedFiles.delete(middleware2);
        }
      }
      if (page || hasSpecial) {
        for (const layout2 of currentLayouts) {
          unusedFiles.delete(layout2);
        }
      }
    }
    if (dir.dirs) {
      for (const child of dir.dirs()) {
        traverse(child);
      }
    }
    if (middleware) {
      currentMiddleware.delete(middleware);
    }
    if (layout) {
      currentLayouts.delete(layout);
    }
  }
}

// src/vite/routes/walk.ts
import fs from "fs";
import path2 from "path";
function createFSWalker(dir) {
  return async function walkFS({
    onEnter,
    onFile,
    onDir,
    maxDepth = 50
  }) {
    async function walk(dir2, depth) {
      const onExit = onEnter == null ? void 0 : onEnter(dir2);
      if (onExit !== false) {
        const dirs = [];
        const entries = await fs.promises.readdir(dir2.path, {
          withFileTypes: true
        });
        const prefix = dir2.path + path2.sep;
        for (const entry of entries) {
          const walkEntry = {
            name: entry.name,
            path: prefix + entry.name
          };
          if (entry.isDirectory()) {
            dirs.push(walkEntry);
          } else {
            onFile == null ? void 0 : onFile(walkEntry);
          }
        }
        if ((onDir == null ? void 0 : onDir()) !== false && --depth > 0) {
          for (const entry of dirs) {
            await walk(entry, depth);
          }
        }
        onExit == null ? void 0 : onExit();
      }
    }
    await walk(
      {
        path: dir,
        name: path2.basename(dir)
      },
      maxDepth
    );
  };
}

// src/vite/utils/ast.ts
import * as t from "@babel/types";
function getExportIdentifiers(astProgramNode) {
  const result = [];
  if (t.isProgram(astProgramNode)) {
    for (const node of astProgramNode.body) {
      if (t.isExportNamedDeclaration(node)) {
        const { declaration, specifiers } = node;
        if (declaration) {
          if (t.isFunctionDeclaration(declaration) && declaration.id) {
            result.push(declaration.id.name);
          } else if (t.isVariableDeclaration(declaration)) {
            for (const declarator of declaration.declarations) {
              if (t.isIdentifier(declarator.id)) {
                result.push(declarator.id.name);
              }
            }
          }
        } else if (specifiers) {
          for (const specifier of specifiers) {
            if (t.isExportSpecifier(specifier) && t.isIdentifier(specifier.exported)) {
              result.push(specifier.exported.name);
            }
          }
        }
      } else if (t.isExportDefaultDeclaration(node)) {
        result.push("default");
      }
    }
  }
  return result;
}
function getViteSSRExportIdentifiers(astProgramNode, exportObjectName = "__vite_ssr_exports__") {
  const result = [];
  if (t.isProgram(astProgramNode)) {
    for (const node of astProgramNode.body) {
      if (t.isExpressionStatement(node)) {
        if (t.isAssignmentExpression(node.expression) && t.isMemberExpression(node.expression.left)) {
          const { object, property } = node.expression.left;
          if (t.isIdentifier(object) && object.name === exportObjectName && t.isIdentifier(property)) {
            result.push(property.name);
          }
        } else if (t.isCallExpression(node.expression) && t.isMemberExpression(node.expression.callee)) {
          const {
            arguments: [arg0, arg1]
          } = node.expression;
          if (t.isIdentifier(arg0) && arg0.name === exportObjectName && (t.isStringLiteral(arg1) || "value" in arg1 && typeof arg1.value === "string")) {
            result.push(arg1.value);
          }
        }
      }
    }
  }
  return result;
}

// src/vite/utils/config.ts
var PluginConfigKey = "__MARKO_RUN_PLUGIN_CONFIG__";
var AdapterConfigKey = "__MARKO_RUN_ADAPTER_CONFIG__";
function getConfig(obj, key) {
  return obj[key];
}
function setConfig(obj, key, value) {
  obj[key] = value;
  return obj;
}
var getExternalPluginOptions = (viteConfig) => getConfig(viteConfig, PluginConfigKey);
var setExternalPluginOptions = (viteConfig, value) => setConfig(viteConfig, PluginConfigKey, value);
var getExternalAdapterOptions = (viteConfig) => getConfig(viteConfig, AdapterConfigKey);

// src/vite/utils/log.ts
import zlib from "node:zlib";
import { Blob } from "buffer";
import Table from "cli-table3";
import format from "human-format";
import kleur2 from "kleur";
var HttpVerbColors = {
  get: kleur2.green,
  head: kleur2.dim().green,
  post: kleur2.magenta,
  put: kleur2.cyan,
  delete: kleur2.red,
  patch: kleur2.yellow,
  options: kleur2.grey
};
function verbColor(verb) {
  return verb in HttpVerbColors ? HttpVerbColors[verb] : kleur2.gray;
}
function logRoutesTable(routes, bundle, options) {
  function getRouteChunkName(route) {
    return options.sanitizeFileName(`${route.entryName}.marko`);
  }
  const hasMiddleware = routes.list.some((route) => route.middleware.length);
  const hasMeta = routes.list.some((route) => route.meta);
  const headings = ["Method", "Path", "Entry"];
  const colAligns = ["left", "left", "left"];
  if (hasMiddleware) {
    headings.push("MW");
    colAligns.push("right");
  }
  if (hasMeta) {
    headings.push("Meta");
    colAligns.push("center");
  }
  headings.push("Size/GZip");
  colAligns.push("right");
  const table = new Table({
    head: headings.map((title) => kleur2.bold(kleur2.white(title.toUpperCase()))),
    wordWrap: true,
    colAligns,
    style: { compact: true }
  });
  for (const route of routes.list) {
    for (const path5 of route.paths) {
      const verbs = getVerbs(route, true);
      let firstRow = true;
      for (const verb of verbs) {
        const entryType = [];
        let size = "";
        let verbCell = verbColor(verb)(verb.toUpperCase());
        if (verb === "get" && !verbs.includes("head")) {
          verbCell += kleur2.dim(`,${verbColor(verb)("HEAD")}`);
        }
        if (route.handler) {
          entryType.push(kleur2.blue("handler"));
        }
        if (route.page && (verb === "get" || verb === "head")) {
          entryType.push(kleur2.yellow("page"));
          if (verb === "get") {
            size = prettySize(
              computeRouteSize(getRouteChunkName(route), bundle)
            );
          }
        }
        const row = [verbCell];
        if (verbs.length === 1 || firstRow) {
          row.push({ rowSpan: verbs.length, content: prettyPath(path5.path) });
          firstRow = false;
        }
        row.push(entryType.join(" -> "));
        hasMiddleware && row.push(route.middleware.length || "");
        hasMeta && row.push(route.meta ? "\u2713" : "");
        row.push(size || "");
        table.push(row);
      }
    }
  }
  for (const [key, route] of Object.entries(routes.special).sort()) {
    const row = [kleur2.bold(kleur2.white("*")), key, kleur2.yellow("page")];
    hasMiddleware && row.push("");
    hasMeta && row.push("");
    row.push(prettySize(computeRouteSize(getRouteChunkName(route), bundle)));
    table.push(row);
  }
  console.log(table.toString());
}
function computeRouteSize(entryName, bundle) {
  for (const chunk of Object.values(bundle)) {
    if (chunk.type === "chunk" && chunk.isEntry && chunk.name === entryName) {
      return computeChunkSize(chunk, bundle);
    }
  }
  return [0, 0];
}
function gzipSize(source) {
  return zlib.gzipSync(source, { level: 9 }).length;
}
function byteSize(source) {
  return new Blob([source]).size;
}
function computeChunkSize(chunk, bundle, seen = /* @__PURE__ */ new Set()) {
  if (chunk.type === "asset") {
    return [byteSize(chunk.source), gzipSize(chunk.source)];
  }
  const size = [byteSize(chunk.code), gzipSize(chunk.code)];
  for (const id of chunk.imports) {
    if (!seen.has(id)) {
      const [bytes, compBytes] = computeChunkSize(bundle[id], bundle, seen);
      size[0] += bytes;
      size[1] += compBytes;
      seen.add(id);
    }
  }
  return size;
}
function prettySize([bytes, compBytes]) {
  if (bytes <= 0) {
    return kleur2.gray("0.0 kB");
  }
  const [size, prefix] = format(bytes, { decimals: 1 }).split(/\s+/);
  const compSize = format(compBytes, { decimals: 1, prefix, unit: "B" });
  let str = kleur2.white(size) + kleur2.gray("/");
  if (compBytes < 20 * 1e3) str += kleur2.green(compSize);
  else if (compBytes < 50 * 1e3) str += kleur2.yellow(compSize);
  else str += kleur2.bold(kleur2.red(compSize));
  return str;
}
function prettyPath(path5) {
  return path5.replace(/\/\$\$(.*)$/, (_, p) => "/" + kleur2.bold(kleur2.dim(`*${p}`))).replace(/\/\$([^/]+)/g, (_, p) => "/" + kleur2.bold(kleur2.dim(`:${p}`)));
}

// src/vite/utils/read-once-persisted-store.ts
import { promises as fs2 } from "fs";
import os from "os";
import path3 from "path";
var noop = () => {
};
var tmpFile = path3.join(os.tmpdir(), "marko-run-storage.json");
var values = /* @__PURE__ */ new Map();
var loadedFromDisk;
var ReadOncePersistedStore = class {
  constructor(uid) {
    this.uid = uid;
  }
  write(value) {
    values.set(this.uid, value);
  }
  async read() {
    const { uid } = this;
    if (values.has(uid)) {
      const value = values.get(uid);
      values.delete(uid);
      return value;
    }
    if (loadedFromDisk === true) {
      throw new Error(`Value for ${uid} could not be loaded.`);
    }
    await (loadedFromDisk || (loadedFromDisk = fs2.readFile(tmpFile, "utf-8").then(syncDataFromDisk).catch(finishLoadFromDisk)));
    return this.read();
  }
};
function syncDataFromDisk(data) {
  finishLoadFromDisk();
  fs2.unlink(tmpFile).catch(noop);
  for (const [k, v] of JSON.parse(data)) {
    values.set(k, v);
  }
}
function finishLoadFromDisk() {
  loadedFromDisk = true;
}
process.once("beforeExit", (code) => {
  if (code === 0 && values.size) {
    fs2.writeFile(tmpFile, JSON.stringify([...values])).catch(noop);
  }
});

// src/vite/plugin.ts
var debug = createDebug("@marko/run");
var __dirname = path4.dirname(fileURLToPath(import.meta.url));
var PLUGIN_NAME_PREFIX = "marko-run-vite";
var POSIX_SEP = "/";
var WINDOWS_SEP = "\\";
var CLIENT_OUT_DIR = "public";
var MIDDLEWARE_FILENAME = `${markoRunFilePrefix}middleware.js`;
var ROUTER_FILENAME = `${markoRunFilePrefix}router.js`;
var defaultPort = Number(process.env.PORT || 3e3);
var normalizePath = path4.sep === WINDOWS_SEP ? (id) => id.replace(/\\/g, POSIX_SEP) : (id) => id;
function markoRun(opts = {}) {
  let { routesDir, adapter, ...markoVitePluginOptions } = opts;
  let store;
  let root;
  let resolvedRoutesDir;
  let entryFilesDir;
  let entryFilesDirPosix;
  let relativeEntryFilesDirPosix;
  let typesDir;
  let isBuild = false;
  let isSSRBuild = false;
  let tsConfigExists;
  let ssrEntryFiles;
  let devEntryFile;
  let devEntryFilePosix;
  let devServer;
  let routes;
  let routeData;
  let getExportsFromFile;
  let resolvedConfig;
  let typesFile;
  const seenErrors = /* @__PURE__ */ new Set();
  const virtualFiles = /* @__PURE__ */ new Map();
  let times = {
    routesBuild: 0,
    routesRender: 0
  };
  async function writeTypesFile(routes2) {
    if (routes2 && (tsConfigExists ?? (tsConfigExists = await globFileExists(
      root,
      "{.tsconfig*,tsconfig*.json}"
    )))) {
      const filepath = path4.join(typesDir, "routes.d.ts");
      const data = await renderRouteTypeInfo(
        routes2,
        normalizePath(path4.relative(typesDir, resolvedRoutesDir)),
        adapter
      );
      if (data !== typesFile || !fs3.existsSync(filepath)) {
        await ensureDir(typesDir);
        await fs3.promises.writeFile(filepath, typesFile = data);
      }
    }
  }
  let buildVirtualFilesResult;
  function buildVirtualFiles() {
    return buildVirtualFilesResult ?? (buildVirtualFilesResult = (async () => {
      virtualFiles.clear();
      routes = await buildRoutes({
        walker: createFSWalker(resolvedRoutesDir),
        importPrefix: routesDir
      });
      if (!routes.list.length) {
        throw new Error("No routes generated");
      }
      for (const route of routes.list) {
        virtualFiles.set(path4.posix.join(root, `${route.entryName}.js`), "");
      }
      if (routes.middleware.length) {
        virtualFiles.set(path4.posix.join(root, MIDDLEWARE_FILENAME), "");
      }
      virtualFiles.set(path4.posix.join(root, ROUTER_FILENAME), "");
      return routes;
    })());
  }
  let renderVirtualFilesResult;
  function renderVirtualFiles(context) {
    return renderVirtualFilesResult ?? (renderVirtualFilesResult = (async () => {
      var _a;
      try {
        const routes2 = await buildVirtualFiles();
        if (fs3.existsSync(entryFilesDir)) {
          fs3.rmSync(entryFilesDir, { recursive: true });
        }
        for (const route of routes2.list) {
          const { handler, page, layouts } = route;
          if (handler) {
            const exports = await getExportsFromFile(context, handler.filePath);
            handler.verbs = [];
            for (const name of exports) {
              const verb = name.toLowerCase();
              if (name === verb.toUpperCase() && httpVerbs.includes(verb)) {
                handler.verbs.push(verb);
              }
            }
            if (!handler.verbs.length) {
              context.warn(
                `Did not find any http verb exports in handler '${path4.relative(root, handler.filePath)}' - expected ${httpVerbs.map((v) => v.toUpperCase()).join(", ")}`
              );
            }
          }
          if (page && layouts.length) {
            const relativePath = path4.relative(
              resolvedRoutesDir,
              page.filePath
            );
            const routeFileDir = path4.join(entryFilesDir, relativePath, "..");
            const routeFileRelativePathPosix = normalizePath(
              path4.relative(routeFileDir, root)
            );
            fs3.mkdirSync(routeFileDir, { recursive: true });
            const pageNameIndex = page.name.indexOf("+page");
            const pageNamePrefix = pageNameIndex > 0 ? `${page.name.slice(0, pageNameIndex)}.` : "";
            fs3.writeFileSync(
              path4.join(routeFileDir, pageNamePrefix + "route.marko"),
              renderRouteTemplate(
                route,
                (to) => path4.posix.join(routeFileRelativePathPosix, to)
              )
            );
          }
          virtualFiles.set(
            path4.posix.join(root, `${route.entryName}.js`),
            renderRouteEntry(route, relativeEntryFilesDirPosix)
          );
        }
        for (const route of Object.values(routes2.special)) {
          const { page, layouts, key } = route;
          if (page && layouts.length) {
            const relativePath = path4.relative(
              resolvedRoutesDir,
              page.filePath
            );
            const routeFileDir = path4.join(entryFilesDir, relativePath, "..");
            const routeFileRelativePathPosix = normalizePath(
              path4.relative(routeFileDir, root)
            );
            fs3.mkdirSync(routeFileDir, { recursive: true });
            fs3.writeFileSync(
              path4.join(routeFileDir, `route.${key}.marko`),
              renderRouteTemplate(
                route,
                (to) => path4.posix.join(routeFileRelativePathPosix, to)
              )
            );
          }
        }
        if (routes2.middleware.length) {
          for (const middleware of routes2.middleware) {
            if (!(await getExportsFromFile(context, middleware.filePath)).includes("default")) {
              context.warn(
                `Did not find a default export in middleware '${path4.relative(root, middleware.filePath)}'`
              );
            }
          }
          virtualFiles.set(
            path4.posix.join(root, MIDDLEWARE_FILENAME),
            renderMiddleware(routes2.middleware)
          );
        }
        virtualFiles.set(
          path4.posix.join(root, ROUTER_FILENAME),
          renderRouter(routes2, relativeEntryFilesDirPosix, {
            trailingSlashes: opts.trailingSlashes || "RedirectWithout"
          })
        );
        await writeTypesFile(routes2);
        if (adapter == null ? void 0 : adapter.routesGenerated) {
          await adapter.routesGenerated(
            routes2,
            new Map(virtualFiles.entries()),
            {
              buildTime: times.routesBuild,
              renderTime: times.routesRender
            }
          );
          if (!isBuild) {
            await ((_a = opts == null ? void 0 : opts.emitRoutes) == null ? void 0 : _a.call(opts, routes2.list));
          }
        }
      } catch (err) {
        if (isBuild) {
          throw err;
        }
        virtualFiles.set(
          path4.posix.join(root, ROUTER_FILENAME),
          `throw ${JSON.stringify(prepareError(err))}`
        );
      }
    })());
  }
  return [
    defaultConfigPlugin,
    {
      name: `${PLUGIN_NAME_PREFIX}:pre`,
      enforce: "pre",
      async config(config2, env) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const externalPluginOptions = getExternalPluginOptions(config2);
        if (externalPluginOptions) {
          opts = mergeConfig(opts, externalPluginOptions);
        }
        root = normalizePath(config2.root || process.cwd());
        isBuild = env.command === "build";
        isSSRBuild = isBuild && Boolean((_a = config2.build) == null ? void 0 : _a.ssr);
        adapter = await resolveAdapter(
          root,
          opts,
          config2.logLevel !== "silent" && !isBuild || isSSRBuild
        );
        if (adapter) {
          (_b = adapter.configure) == null ? void 0 : _b.call(adapter, {
            ...getExternalAdapterOptions(config2),
            root,
            isBuild
          });
          const adapterOptions = await ((_c = adapter.pluginOptions) == null ? void 0 : _c.call(adapter, opts));
          if (adapterOptions) {
            opts = mergeConfig(opts, adapterOptions);
          }
        }
        routesDir = opts.routesDir || "src/routes";
        store = new ReadOncePersistedStore(
          `vite-marko-run${opts.runtimeId ? `-${opts.runtimeId}` : ""}`
        );
        markoVitePluginOptions.runtimeId = opts.runtimeId;
        markoVitePluginOptions.basePathVar = opts.basePathVar;
        resolvedRoutesDir = path4.resolve(root, routesDir);
        entryFilesDir = path4.join(
          getModulesDir(root),
          ".marko",
          createHash("shake256", { outputLength: 4 }).update(root).digest("hex")
        );
        entryFilesDirPosix = normalizePath(entryFilesDir);
        relativeEntryFilesDirPosix = normalizePath(
          path4.relative(root, entryFilesDir)
        );
        typesDir = path4.join(root, ".marko-run");
        devEntryFile = path4.join(root, "index.html");
        devEntryFilePosix = normalizePath(devEntryFile);
        let outDir = ((_d = config2.build) == null ? void 0 : _d.outDir) || "dist";
        const assetsDir = ((_e = config2.build) == null ? void 0 : _e.assetsDir) || "assets";
        let rollupOutputOptions = (_g = (_f = config2.build) == null ? void 0 : _f.rollupOptions) == null ? void 0 : _g.output;
        if (isBuild) {
          if (!isSSRBuild) {
            outDir = path4.join(outDir, CLIENT_OUT_DIR);
          }
          const defaultRollupOutputOptions = {
            assetFileNames({ name }) {
              if (name && name.indexOf("_marko-virtual_id_") < 0) {
                return `${assetsDir}/${getEntryFileName(name) || "[name]"}-[hash].[ext]`;
              }
              return `${assetsDir}/_[hash].[ext]`;
            },
            entryFileNames(info) {
              let name = getEntryFileName(info.facadeModuleId);
              if (!name) {
                for (const id of info.moduleIds) {
                  name = getEntryFileName(id);
                  if (name) {
                    break;
                  }
                }
              }
              return `${assetsDir}/${name || "[name]"}-[hash].js`;
            },
            chunkFileNames: isSSRBuild ? `_[hash].js` : `${assetsDir}/_[hash].js`
          };
          if (!rollupOutputOptions) {
            rollupOutputOptions = defaultRollupOutputOptions;
          } else if (!Array.isArray(rollupOutputOptions)) {
            rollupOutputOptions = {
              ...defaultRollupOutputOptions,
              ...rollupOutputOptions
            };
          } else {
            rollupOutputOptions = rollupOutputOptions.map((options) => ({
              ...defaultRollupOutputOptions,
              ...options
            }));
          }
        }
        const browserslistTarget = isBuild && !((_h = config2.build) == null ? void 0 : _h.target) ? browserslist(void 0, {
          path: root
        }) : void 0;
        let pluginConfig = {
          logLevel: isBuild ? "warn" : void 0,
          define: isBuild ? {
            "process.env.NODE_ENV": "'production'"
          } : void 0,
          ssr: {
            noExternal: /@marko\/run($|\/)/
          },
          css: {
            devSourcemap: true
          },
          build: {
            outDir,
            assetsDir,
            target: (browserslistTarget == null ? void 0 : browserslistTarget.length) ? resolveToEsbuildTarget(browserslistTarget, {
              printUnknownTargets: false
            }) : void 0,
            emptyOutDir: isSSRBuild,
            // Avoid server & client deleting files from each other.
            copyPublicDir: !isSSRBuild,
            ssrEmitAssets: false,
            rollupOptions: {
              output: rollupOutputOptions
            },
            modulePreload: { polyfill: false },
            sourcemap: ((_i = config2.build) == null ? void 0 : _i.sourcemap) ?? (isBuild && !isSSRBuild)
          },
          optimizeDeps: {
            entries: !((_j = config2.optimizeDeps) == null ? void 0 : _j.entries) ? [
              "src/pages/**/*+{page,layout}.marko",
              "!**/__snapshots__/**",
              `!**/__tests__/**`,
              `!**/coverage/**`
            ] : void 0
          },
          resolve: isBuild ? {
            mainFields: (isSSRBuild ? [] : ["browser"]).concat([
              "module",
              "jsnext:main",
              "jsnext",
              "main"
            ]),
            conditions: [
              isSSRBuild ? "node" : "browser",
              "import",
              "require",
              "production",
              "default"
            ]
          } : void 0
        };
        if (adapter == null ? void 0 : adapter.viteConfig) {
          const adapterConfig = await adapter.viteConfig(config2);
          if (adapterConfig) {
            pluginConfig = mergeConfig(pluginConfig, adapterConfig);
          }
        }
        return setExternalPluginOptions(pluginConfig, opts);
      },
      configResolved(config2) {
        resolvedConfig = config2;
        const {
          ssr,
          rollupOptions: { input }
        } = config2.build;
        if (typeof ssr === "string") {
          ssrEntryFiles = [ssr];
        } else if (typeof input === "string") {
          ssrEntryFiles = [input];
        } else if (Array.isArray(input)) {
          ssrEntryFiles = input;
        } else if (input) {
          ssrEntryFiles = Object.values(input);
        } else {
          ssrEntryFiles = [];
        }
        const baseError = config2.logger.error;
        config2.logger.error = function(msg, options) {
          var _a;
          if (!((_a = options == null ? void 0 : options.error) == null ? void 0 : _a.message)) {
            baseError.call(this, msg, options);
          } else if (!seenErrors.has(options.error.message)) {
            seenErrors.add(options.error.message);
            console.error(buildErrorMessage(options.error));
          }
        };
      },
      configureServer(_server) {
        devServer = _server;
        devServer.watcher.on("all", async (type, filename) => {
          seenErrors.clear();
          const routableFileType = matchRoutableFile(
            path4.parse(filename).base
          );
          if (filename.startsWith(resolvedRoutesDir) && routableFileType) {
            if (type === "add" || type === "unlink" || type === "change" && (routableFileType === RoutableFileTypes.Handler || routableFileType === RoutableFileTypes.Middleware)) {
              buildVirtualFilesResult = void 0;
              renderVirtualFilesResult = void 0;
              const module = devServer.moduleGraph.getModuleById(filename);
              const importers = module && getImporters(module, filename);
              if (importers == null ? void 0 : importers.size) {
                for (const file of importers) {
                  devServer.watcher.emit("change", file);
                }
              } else {
                for (const file of virtualFiles.keys()) {
                  if (!file.endsWith(".marko")) {
                    devServer.watcher.emit("change", file);
                  }
                }
              }
            }
          }
        }).unwatch(typesDir + "/*");
      },
      async buildStart(_options) {
        if (isBuild && !isSSRBuild) {
          try {
            routeData = await store.read();
          } catch {
            this.error(
              `You must run the "ssr" build before the "browser" build.`
            );
          }
          routes = routeData.routes;
          times = routeData.times;
          for (const { key, code } of routeData.files) {
            virtualFiles.set(key, code);
          }
          buildVirtualFilesResult = Promise.resolve(routes);
          renderVirtualFilesResult = Promise.resolve();
        } else {
          getExportsFromFile = isBuild ? getExportsFromFileBuild : getExportsFromFileDev.bind(null, devServer);
        }
      },
      async resolveId(importee, importer) {
        if (importee === "@marko/run/router") {
          return normalizePath(path4.resolve(root, ROUTER_FILENAME));
        } else if (importee.endsWith(".marko") && importee.includes(relativeEntryFilesDirPosix)) {
          if (!importee.startsWith(root)) {
            importee = path4.resolve(root, "." + importee);
          }
          return normalizePath(importee);
        }
        let virtualFilePath;
        if (importee.startsWith(virtualFilePrefix)) {
          virtualFilePath = importee.slice(virtualFilePrefix.length + 1);
          importee = path4.resolve(root, virtualFilePath);
        } else if (!isBuild && importer && (importer === devEntryFile || normalizePath(importer) === devEntryFilePosix) && importee.startsWith(`/${markoRunFilePrefix}`)) {
          importee = path4.resolve(root, "." + importee);
        }
        importee = normalizePath(importee);
        if (!buildVirtualFilesResult) {
          await buildVirtualFiles();
        }
        if (virtualFiles.has(importee)) {
          return importee;
        } else if (virtualFilePath) {
          const filePath = path4.resolve(__dirname, "..", virtualFilePath);
          return await this.resolve(filePath, importer, {
            skipSelf: true
          });
        }
      },
      async load(id) {
        if (id.endsWith(serverEntryQuery)) {
          id = id.slice(0, -serverEntryQuery.length);
        }
        if (!renderVirtualFilesResult) {
          await renderVirtualFiles(this);
        }
        if (virtualFiles.has(id)) {
          return virtualFiles.get(id);
        } else if (!id.startsWith(entryFilesDirPosix) && /[/\\]__marko-run__[^?/\\]+\.(js|marko)$/.exec(id)) {
          return "";
        }
      }
    },
    ...markoVitePlugin(markoVitePluginOptions),
    {
      name: `${PLUGIN_NAME_PREFIX}:post`,
      enforce: "post",
      generateBundle(options, bundle) {
        if (options.sourcemap && options.sourcemap !== "inline") {
          for (const key of Object.keys(bundle)) {
            if (key.endsWith(".map") && !bundle[key.slice(0, -4)]) {
              delete bundle[key];
            }
          }
        }
      },
      async writeBundle(options, bundle) {
        var _a;
        if (isSSRBuild) {
          const builtEntries = Object.values(bundle).reduce(
            (acc, item) => {
              if (item.type === "chunk" && item.isEntry) {
                acc.push(path4.join(options.dir, item.fileName));
              }
              return acc;
            },
            []
          );
          routeData = {
            routes,
            files: [],
            times,
            builtEntries,
            sourceEntries: ssrEntryFiles
          };
          for (const [key, code] of virtualFiles) {
            routeData.files.push({ key, code });
          }
          store.write(routeData);
          await ((_a = opts == null ? void 0 : opts.emitRoutes) == null ? void 0 : _a.call(opts, routes.list));
        } else if (process.env.MR_EXPLORER !== "true") {
          logRoutesTable(routes, bundle, options);
        }
      },
      async closeBundle() {
        if (isBuild && !isSSRBuild && (adapter == null ? void 0 : adapter.buildEnd) && routes) {
          await adapter.buildEnd(
            resolvedConfig,
            routes.list,
            routeData.builtEntries,
            routeData.sourceEntries
          );
        }
      }
    }
  ];
}
async function getExportsFromFileBuild(context, filePath) {
  const result = await context.load({
    id: filePath,
    resolveDependencies: false
  });
  return result ? getExportIdentifiers(result.ast) : [];
}
async function getExportsFromFileDev(devServer, context, filePath) {
  const result = await devServer.transformRequest(filePath, { ssr: true });
  if (result) {
    const ast = context.parse(result.code);
    return getViteSSRExportIdentifiers(ast);
  }
  return [];
}
async function globFileExists(root, pattern) {
  return (await glob(pattern, { root })).length > 0;
}
async function ensureDir(dir) {
  if (!fs3.existsSync(dir)) {
    await fs3.promises.mkdir(dir, { recursive: true });
  }
}
async function getPackageData(dir) {
  do {
    const pkgPath = path4.join(dir, "package.json");
    if (fs3.existsSync(pkgPath)) {
      return JSON.parse(await fs3.promises.readFile(pkgPath, "utf-8"));
    }
  } while (dir !== (dir = path4.dirname(dir)));
  return null;
}
async function resolveAdapter(root, options, log) {
  if (options && options.adapter !== void 0) {
    return options.adapter;
  }
  const pkg = await getPackageData(root);
  if (pkg) {
    let dependecies = pkg.dependencies ? Object.keys(pkg.dependencies) : [];
    if (pkg.devDependencies) {
      dependecies = dependecies.concat(Object.keys(pkg.devDependencies));
    }
    for (const name of dependecies) {
      if (name.startsWith("@marko/run-adapter") || name.indexOf("marko-run-adapter") !== -1) {
        try {
          const module2 = await import(
            /* @vite-ignore */
            name
          );
          log && debug(
            `Using adapter ${name} listed in your package.json dependecies`
          );
          return module2.default();
        } catch (err) {
          log && debug(`Attempt to use package '${name}' failed %O`, err);
        }
      }
    }
  }
  const defaultAdapter = "@marko/run/adapter";
  const module = await import(
    /* @vite-ignore */
    defaultAdapter
  );
  log && debug("Using default adapter");
  return module.default();
}
var markoEntryFileRegex = /__marko-run__([^.]+)(?:\.(.+))?\.marko\.([^.]+)$/;
function getEntryFileName(file) {
  const match = file && markoEntryFileRegex.exec(file);
  return match ? match[2] || "index" : void 0;
}
function getImporters(module, fileName, seen = /* @__PURE__ */ new Set()) {
  for (const importer of module.importers) {
    if (importer.id && !seen.has(importer.id)) {
      seen.add(importer.id);
      getImporters(importer, fileName, seen);
    }
  }
  return seen;
}
function getModulesDir(root, dir = __dirname) {
  if (dir.startsWith(root)) {
    const index = dir.indexOf("node_modules");
    if (index >= 0) {
      return dir.slice(0, index + 12);
    }
  }
  return path4.join(root, "node_modules");
}
var defaultConfigPlugin = {
  name: `${PLUGIN_NAME_PREFIX}:defaults`,
  enforce: "pre",
  config(config2) {
    var _a, _b;
    return {
      server: {
        port: ((_a = config2.server) == null ? void 0 : _a.port) ?? defaultPort
      },
      preview: {
        port: ((_b = config2.preview) == null ? void 0 : _b.port) ?? defaultPort
      }
    };
  }
};

// src/vite/utils/server.ts
import cp from "child_process";
import cluster from "cluster";
import { config, parse } from "dotenv";
import fs4 from "fs";
import net from "net";
async function parseEnv(envFile) {
  if (fs4.existsSync(envFile)) {
    const content = await fs4.promises.readFile(envFile, "utf8");
    return parse(content);
  }
}
function loadEnv(envFile) {
  config({ path: envFile });
}
async function spawnServer(cmd, args = [], port = 0, env, cwd = process.cwd(), wait = 3e4, stdio = ["ignore", "inherit", "inherit"]) {
  if (port <= 0) {
    port = await getAvailablePort();
  }
  if (typeof env === "string") {
    env = await parseEnv(env);
  }
  const proc = cp.spawn(cmd, args, {
    cwd,
    shell: true,
    stdio,
    windowsHide: true,
    env: { ...env, NODE_ENV: "development", ...process.env, PORT: `${port}` }
  });
  const close = () => {
    proc.unref();
    proc.kill();
  };
  try {
    await Promise.race([waitForError(proc, port), waitForServer(port, wait)]);
  } catch (err) {
    close();
    throw err;
  }
  return {
    port,
    close
  };
}
async function spawnServerWorker(module, args = [], port = 0, env, wait = true) {
  if (port <= 0) {
    port = await getAvailablePort();
  }
  if (typeof env === "string") {
    env = await parseEnv(env);
  }
  const originalExec = cluster.settings.exec;
  const originalArgs = cluster.settings.execArgv;
  try {
    cluster.settings.exec = module;
    cluster.settings.execArgv = args;
    const worker = cluster.fork({
      ...env,
      NODE_ENV: "development",
      ...process.env,
      PORT: `${port}`
    });
    if (wait) {
      return new Promise((resolve) => {
        function ready(message) {
          if (message === "ready") {
            worker.off("message", ready);
            resolve(worker);
          }
        }
        worker.on("message", ready);
      });
    }
    return worker;
  } finally {
    cluster.settings.exec = originalExec;
    cluster.settings.execArgv = originalArgs;
  }
}
async function waitForError(proc, port) {
  return new Promise((_, reject) => {
    proc.once("error", reject);
    proc.once("exit", (code) => {
      reject(
        new Error(
          `Process exited with code ${code} while waiting for server to start on port "${port}".`
        )
      );
    });
  });
}
async function waitForServer(port, wait = 0) {
  let remaining = wait > 0 ? wait : Infinity;
  let connection;
  while (!(connection = await getConnection(port))) {
    if (remaining >= 100) {
      remaining -= 100;
      await sleep(100);
    } else {
      throw new Error(
        `Timeout while wating for server to start on port "${port}".`
      );
    }
  }
  return connection;
}
async function getConnection(port) {
  return new Promise((resolve) => {
    const connection = net.connect(port).setNoDelay(true).setKeepAlive(false).on("error", () => {
      connection.end();
      resolve(null);
    }).on("connect", () => {
      resolve(connection);
    });
  });
}
async function isPortInUse(port) {
  return Boolean(await getConnection(port));
}
async function getAvailablePort(port) {
  if (port && !await isPortInUse(port)) {
    return port;
  }
  return new Promise((resolve) => {
    const server = net.createServer().listen(0, () => {
      const { port: port2 } = server.address();
      server.close(() => resolve(port2));
    });
  });
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
export {
  markoRun as default,
  getAvailablePort,
  getPackageData,
  isPortInUse,
  loadEnv,
  parseEnv,
  spawnServer,
  spawnServerWorker
};
